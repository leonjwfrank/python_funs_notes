#golang-core##	数据结构###		1 numeral system：数字系统			decimal:小数，即一般的int				fmt.Println(1.2+111113.9i)			binary:二进制				fmt.Printf("%d - %b \n", 42, 42)			hexadecimal:十六进制				fmt.Printf("%d \t %b \t %#X \n", 42, 42, 42)			loop:循环				for i := 1000000; i < 1000100; i++ {\n   fmt.Printf("%d \t %b \t %x \\n", i, i, i)			remainder：余数的处理				x := 13 % 3\nfmt.Println(x)			运算符，数字越大表示优先级越高				算术运算符					[优先级11 ( 加+  减- ),  优先级12 ( 乘*  除/  求余% ) ]				关系运算符					优先级9 [<、<=、>、>= , ==, !=] 				逻辑运算符					优先级4 逻辑与&&,   优先级3 逻辑或 ||,  优先级13  逻辑否 !				位运算符					双目运算符   [优先级5，6，7：按位与（&）, 按位或（|）,   按位异或( ^) ，  优先级10 左移 <<, 右移 >> ]					A&B  //表示A和B各对应的二进位相与				赋值运算符					优先级2，从右到左 运算						=、+=、-=、*=、/=(相除后再赋值)、 %=(求余后再赋值)、 >>=(右移后赋值)、 <<=(左移后赋值)、&=(按位与后赋值)、^=(按位异或后赋值)、|=(按位或 然后赋值)				单目运算符,从右到左运算					优先级13 (自增++  自减-- +（正号）-（负号)  !否 *（指针）&取地址 					&a  //表示取a的地址				优先级					括号最高，() > || >  && > (==, !=, <, <=, >, >=) > (+ - | ^)  > (* / % << >> & &^)  > , (逗号)###		2 字符串:UTF-8 包含运算符号和字母数字string			for i := 60; i < 122; i++ {\n   fmt.Printf("%d \t %b \t %x \t %q \\n", i, i, i, i)###		3 变量 variables			less_emphasis: 		*declare-variable：变量声明					var message string\nmessage = "Hello World."\nfmt.Println(message)		*同一行多个变量声明					var message string\nvar a, b, c int\na = 1\nmessage = "Hello World!"\nfmt.Println(message, a, b, c)		*同一行多个int类型声明					var message = "Hello World!"\nvar a, b, c int = 1, 2, 3\nfmt.Println(message, a, b, c)		*类型推断: infer type,不指明类型int					var message = "Hello World!"\nvar a, b, c = 1, 2, 3\nfmt.Println(message, a, b, c)		*多个类型推断:infer-mixed-up-type					var message = "Hello World!"\nvar a, b, c = 1, false, 3\nfmt.Println(message, a, b, c)		*初始化短符号init-shorthand：					message := "Hello World!"\na, b, c := 1, false, 3\nd := 4\ne := true\nfmt.Println(message, a, b, c, d, e)		*反引号与双引号等效:"Jack", `Jack`					name := `Todd` // 反引号\nfmt.Println("Hello ", name)					name := "Todd"\nfmt.Println("Hello ", name)		*var_zero-value:零变量				var a int\nvar b string\nfmt.Printf("%v \\n", a)\nfmt.Printf("%v \\n", b)\nfmt.Println()  //多一个这个打印		*shorthand：短符号				a := 10\nb := "golang"\nfmt.Printf("%T \\n", a)\nfmt.Printf("%T \\n", b)				a := 10\nb := "golang" \nfmt.Printf("%v \\n", a)\nfmt.Printf("%v \\n", b)###		4 包检索范围 Scope		*包内引用 package-scope				var x = 42\nfunc main() {\n   fmt.Println(x)\n   foo()}\nfunc foo() {\n   fmt.Println(x)}		*块范围 block scope				x := 0\nincrement := func() int {\n   x++\n   return x}\nfmt.Println(increment())\nfmt.Println(increment())				func wrapper() func() int {\n   x := 0\n   return func() int {\n	  x++\n	  return x\n   }}\nfunc main() {\n   increment := wrapper()\n   fmt.Println(increment())\n   fmt.Println(increment())}				变量与函数重名：variable  shadowing					func max(x int) int {\n   return 42 + x}\nfunc main() {\n   max := max(7)\n   fmt.Println(max) // max现在是结果，而不是函数}				需要go1.15才能支持的功能：					包名与函数名一样						一个目录下，两个模块声明都是package main					无法完成引用函数变量，没有在main中指定						func main() {\n   x := 42\n   fmt.Println(x)\n   foo()}\nfunc foo() {\n   // no access to x\n   // this does not compile\n   fmt.Println(x)}					序列事件 order-matters:						func main() {\n   fmt.Println(x)\n   fmt.Println(y)\n   x := 42\n}\nvar y = 42###		5 blank-identifier：空白标识符			不允许 变量 已声明但未使用				func main() {\n   a := "stored in a"\n   b := "stored in b"\n   fmt.Println("a - ", a)\n   // b is not being used - invalid code\n}			http调用范本				包含错误检查					import (\n"fmt"\n"io/ioutil"\n"log"\n"net/http"\n) \nfunc main() { res, err := http.Get("http://www.geekwiseacademy.com/")\nif err != nil {\nlog.Fatal(err)\n}\npage, err := ioutil.ReadAll(res.Body)\nres.Body.Close()\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf("%s", page)\n}				不包含错误检查					import (\n   "fmt"\n   "io/ioutil"\n   "net/http"\n)\nfunc main() {\n   res, _ := http.Get("http://www.geekwiseacademy.com/")\n   page, _ := ioutil.ReadAll(res.Body)\n   res.Body.Close()\n   fmt.Printf("%s", page)\n}###		6 constants 常量		*不同区域范围定义常量				const p = "death & taxes"\nfunc main() {\n   const q = 42\n   fmt.Println("p - ", p)\n   fmt.Println("q - ", q)\n}		*同时定义多个常量				const (\n   pi       = 3.14\n   language = "Go"\n)\nfunc main() {\n   fmt.Println(pi)\n   fmt.Println(language)\n}		*iota 枚举				枚举值 全部赋值					const (\na = iota // 0\nb = iota // 1\nc = iota // 2\n)\nfunc main() {\nfmt.Println(a, b, c)\n}				只写第一个枚举值，其他自动+1					const (\n   a = iota // 0\n   b        // 1\n   c        // 2\n)\nfunc main() {\nfmt.Println(a, b, c)\n}				同时定义多个枚举列表					const (\n   a = iota // 0\n   b        // 1\n   c        // 2\n)\nconst (\n   d = iota // 0\n   e        // 1\n   f        // 2\n)\nfunc main() {\n   fmt.Println(a,b,c,d,e,f)}				操作其他位置的枚举值，不影响其他位置的值					const (\n   _ = iota      // 0\n   b = iota * 10 // 1 * 10\n   c = iota * 10 // 2 * 10\n)\nfunc main() {\n   fmt.Println(b,c)\n}				枚举常量定义，位操作					const (\n   _  = iota             // 0\n   KB = 1 << (iota * 10) // 1 << (1 * 10)\n   MB = 1 << (iota * 10) // 1 << (2 * 10)\n   GB = 1 << (iota * 10) // 1 << (3 * 10)\n   TB = 1 << (iota * 10) // 1 << (4 * 10)\n)\nfunc main() {\n   fmt.Println("binary\t\tdecimal")\n   fmt.Printf("%b\t", KB)\n   fmt.Printf("%d\\n", KB)\n   fmt.Printf("%b\t", MB)\n   fmt.Printf("%d\\n", MB)\n   fmt.Printf("%b\t", GB)\n   fmt.Printf("%d\\n", GB)\n   fmt.Printf("%b\t", TB)\n   fmt.Printf("%d\\n", TB)\n}						binary		decimal\n10000000000	1024\n100000000000000000000	1048576\n1000000000000000000000000000000	1073741824\n10000000000000000000000000000000000000000	1099511627776		*数据类型转换			int -> float				s, s1 := 11, 11.11111\nfmt.Println(s1 + float64(s))			float -> int				s, s1 := 11,  11.11111\nfmt.Println(int(s1) + s)			符号类型(其实就是int32) rune -> 字符 string				as := 'a'; print(as);   print(string(as)) //97 a			bytes切片到字符: []bytes to string				rs := []byte{'h', 'e', 'l', 'l', 'o'}  // rune to slice\nfmt.Println(rs) //[104 101 108 108 111]\nfmt.Println(string(rs)) //hello			字符到 切片: []bytes				str := []byte("hello")\nprint(str)  // 0xc000070090\nfmt.Println(str)  //[104 101 108 108 111]			strconv 字符数字转换 int或float: strconv				s := "1.1314";fmt.Printf("%T  \\n", s);z1, _:= strconv.ParseFloat(s, 64);fmt.Println(float64(z) + z1)  //1.1314				i, _ := strconv.ParseInt("-42", 10, 64) //-42				u, _ := strconv.ParseUint("42", 10, 64) //42				b, _ := strconv.ParseBool("true") //true				ia,_ := strconv.Atoi("-11")  //-11				//  FormatBool, FormatFloat, FormatInt, and FormatUint 将值转为字符串:\nw := strconv.FormatBool(true)       // "true"\nx := strconv.FormatFloat(3.1415, 'E', -1, 64) //3,1415E+00\ny := strconv.FormatInt(-42, 16) //-2a\nz := strconv.FormatUint(42, 16) //2a			strconv.itoa				Itoa等效于FormatInt（int64（i），10）			接口强制转换错误 需要类型断言				var val interface{} = 7;fmt.Println(val.(int) + 6)  //正确调用  13				var val interface{} = 7;fmt.Printf("%T \\n", val.(int))  //// 转换接口的 int 类型数据 需要 先取出值			特性				1 接口的多态：多态是编写代码的能力，该代码可以通过以下方式采取不同的行为： 类型的实现。一旦类型实现了接口，整个世界可以向该类型的值开放功能 --go 作者 Bill Kennedy				2 接口是仅声明行为的类型。这种行为永远不会由 接口类型直接定义，一般是通过方法由用户定义的类型代替。当用户定义的类型 实现由接口类型 声明的 方法集，其值是用户定义的类型可以分配给接口类型的值。这项任务将用户定义类型的值存储到接口值中。\n 如果针对接口值进行方法调用，则执行存储的用户定义值。由于任何用户定义的类型都可以实现任何接口，针对接口值的方法调用本质上是多态的。这种关系中的用户定义类型通常称为具体类型，因为接口值如果不执行存储的用户定义值，则没有任何具体行为。				3  从概念上讲，接口类型的值或接口值具有两个组成部分， CONCRETE TYPE 类型和该类型的值 a Value of that Type。这些称为接口的动态类型(DYNAMIC TYPE)和动态值(DYNAMIC VALUE)。				4 对于像Go这样的静态类型语言，类型是编译时的概念，因此类型不是值。在我们的概念模型中，一组称为TYPE DESCRIPTORS的值提供了有关每种类型的信息，例如其名称和方法。在接口值中，类型组件由适当的表示类型描述符。					var w io.Writer\nw = os.Stdout\nw = new(bytes.Buffer)\nw = nil					var w io.Writer\nw\ntype: nil\nvalue: nil###	特性：相对于python		*系统编程		*并发编程，异步			var wg sync.WaitGroup				wg.Add(2)\ngo foo()\ngo bar()\nwg.Wait()				foo(){time.Sleep(3 * time.Millisecond)\nwg.Done()}		*过程编程		*错误，而不是 抛出异常			编译时错误：程序在尝试构建程序时发现错误时，就会发生编译时错误。比如 语法错误，直接赋值越界 overflow\n\n运行时错误：程序实际执行后，在编译程序后会发生运行时错误， 比如 参数定义 var ai8 = 3000 //大于int8， 在运行时 打印参数 ai8 结果却是 0 或负数，这被go自动环绕到0 了			如定义个值 int8类型 然后 在运行时+1越界，go的运行结果 可能是负数 或 0 ： int8 127  int8 -128				var ai8 int8 = 127\nfmt.Println(reflect.TypeOf(ai8), ai8)  //类型查看\nai8 = ai8 + 1\nfmt.Println(reflect.TypeOf(ai8), ai8)  //类型查看		*结构体，而不是面向对象			go面向对象封装				- you don't create classes, you create a type\n- you don't instantiate, you create a value of a type				state ("fields") 状态（“字段”）\nbehavior ("methods") 行为（“方法”）\nexported / un-exported  异常/没有异常定义		*没有类，也就没有继承			go继承 inheritence 				嵌入式类型 ("embedded types") 			go多态 Polymorphism				接口 interfaces			go重载 Overriding				promotion		*Goroutines：   routines 例行程序			类型别名(并不常用) alias type not idiomatic				type foo int # 用户定义的类型-我们声明一个新类型foo foo的基本类型：int					var myAge foo  # conversion：int（myAge） 将foo类型转换为int类型\nmyAge = 44\nfmt.Printf("%T %v \\n", myAge, myAge)				静态类型					var yourAge int\nyourAge = 29\nfmt.Printf("%T %v \\n", yourAge, yourAge)		*接口：例行程序的接口			接口 使得 有多个相同 目标的 结构体 和函数 可以 简单的方式 被访问			同时定义 正方形 和 圆的 面积计算函数 				func (s square) area() float64 {				func (c circle) area() float64 {		*强制类型转换 和 类型断言			强制类型转换				import "unsafe"  //强制转换 int 为 int64					var a int =10\nvar b *int =&a\nvar c *int64 = (*int64)(unsafe.Pointer(b))			类型断言				接口类型判断					// 接口类型判断\nvar e interface{} = 11\nt2, ok:= e.(int)\nif ok{\n   fmt.Println("int",t2, e, "ok", ok)\n}			类型查看				var c int =10\n// 类型检查\nfmt.Println(reflect.TypeOf(c))  //int\nfmt.Println(reflect.TypeOf(*c)) //int			规则转换变量类型：将int转换为string值，将string转换为对应int值				 reflect.Value.Convert 					foo := "a"\nfor i := 250; i <= 340; i++ {\n   fmt.Println(i, " - ", string(i), " - ", []byte(string(i)))\n   fmt.Println(reflect.TypeOf(i), reflect.TypeOf(foo), []byte(foo))\n}		*输入输出捕获			golang				var name string\nfmt.Print("Please enter your name: ")\nfmt.Scan(&name)\nfmt.Println("Hello", name)			py				name=input("Please enter your name:")\nprint(name)			输出				控制台打印					golang						print, fmt.Println(),  fmt.Printf(), (printstring,printint, 新增功能与1.15版本)						print 默认不换行，fmt.Pringln 默认换行						打印自定义字符，包括字符串自定义的 符号为 反引号 ` 或双引号 "						单引号 表示 rune 类型							letter := 'A' # 此处 letter实际使用println查看值为:  65								fmt.Printf("%T ", letter) #查看格式 int32					python: sys.stdout # 某些流会缓冲某些I/O操作以提高性能 减少昂贵的I/O调用次数						print默认换行							 						控制台 输出流缓存,无法控制print的编码问题							print（）是对底层的抽象，提供了一个方便的接口，只是将实际打印委托给流或类文件对象。流可以是磁盘上的任何文件，网络套接字或内存缓冲区。						流的重定向							print(b'\x41') # 将得到 b'A'						print 输出缓存							Unbuffered 不缓存\nLine-buffered 缓存直到换行\nBlock-buffered 缓存达到某个量以后才输出						自定义类的输出属性 简短的人类可读关键信息__str__ （当直接打印print(person)）将会调用该__str__方法, __repr__ （用于传递给eval，解析类的全部属性）							def __str__(self):\n	    return f'Person name={self.name}'\n	def __repr__(self):\n	    return f"Person(name='{self.name}', age={self.age})"\njd = Person('John Doe', 42);print(jd)		*内置测试模块			golang				go test -bench='.*' #在命令行执行该指令					import (\n   "fmt"\n   "testing"\n)\nfunc BenchmarkHello(b *testing.B) {\n   for i := 0; i < b.N; i++ {\n	  fmt.Sprintf("hello")\n   }\n}					输出: PASS  ok    			python				import unittest; unitest.main();  python -m test###	包管理		https://www.honeybadger.io/blog/golang-go-package-management/		*go get #安装依赖			go get github.com/GoesToEleven/GolangTraining #安装依赖			require github.com/GoesToEleven/GolangTraining v0.0.0-20181204234241-afa19f5c43f3 // indirect// indirect评论指出，这包不是目前在项目中使用。\n当程序包是间接依赖项（即另一个依赖项的依赖项）时，您也可能会看到此注释			依赖包升级				go get -u或go get -u=patch将软件包升级到其最新的次要版本或修补程序版本		*go install:在软件包的源目录中运行时它将编译该软件包的最新版本及其在pkg目录中的所有依赖项		*go mod tidy #清理未使用的，或添加缺少的依赖项			在发布项目的新版本之前和每次提交之前，应运行\n\ngo mod tidy命令以确保模块文件干净且准确			在终端中运行命令以更新go.mod文件。\n此命令将删除项目中未使用的依赖项，并添加所有缺少的依赖项		*go sum			您可以将其视为附加验证，以确保项目所依赖的模块不会由于恶意，意外或其他原因而意外更改			预期加密哈希值，进行维护		*依赖删除			1 在项目中删除 相关引用即可			2 go mod tidy 运行以清理go.mod				即使删除了依赖， go.sum中也有软件包加密哈希		*go mod vendor #将第三方依赖复制到项目根目录文件夹 			供应商是复制项目所依赖的第三方程序包并将其放置在\nvendor项目内的目录中的行为。这是无需依赖外部服务即可确保生产版本稳定性的一种方法		*go mod init 将初始化您项目中的模块。			一个项目创建后，一般步骤是, 1,初始化 go init ginweb; 2, 安装依赖 go install github/gin; 3,编译 go build main.go; 4,运行 go run main.go		*go build  # 编译项目和依赖，不会进行安装		*go get -u github.com/gin-gonic/gin # 安装gin###	开发工具		goland, vscode###	关键字 25个		*功能修饰符			defer:用于推迟执行功能，直到周围功能开始执行			go: golang运行管理触发一个go程序		*声明			const：创建常量			var:创建变量			func:声明函数			type:使用type来引入新的stuct类型			import:用于导入软件包			package:用于在程序中定义一个单元			:=, 简短变量声明				x := 13 % 3		*复合类型			chan: 用于定义通道，允许你并行允许代码			interface：用于指定方法集（某一种相同类型的方法列表）			map:用于映射键值对的 无序集合			struct:字段的集合，可以在字段声明后使用struct		*流控制			break:终止循环，并执行其他代码			case:属于switch构造的一种形式，在切换后指定一个变量			continue：使代码可以返回到for循环			default: 可选语句，在switch语句中，使用大小写或默认值，如果大小写与控制表达式不匹配 则使用default值			if-else: 条件语句			fallthrough:在switch语句内使用此关键字，使用它时将输入下一种情况			for: 使用for开启一个for循环				使用for来便利 map 字典取值					for key, val := range myGreeting {\n   fmt.Println(key, " - ", val)\n}			goto:可以无条件的跳转至带标签语句			range:用于读取slice、map、channel数据 遍历项目在像图或数组列表项			return: go允许您将返回值用作变量，从函数返回			select:使goroutine在同步操作 期间等待			switch:用于启动循环并在块中使用 if-else###	web后端api工具		*使用内建库 开发 restful api			package main\n\nimport (\n   "io"\n   "net/http"\n)\n\ntype myHandler int\n\nfunc (h myHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n   res.Header().Set("Content-Type", "text/html; charset=utf-8")\n   switch req.URL.Path {\n   case "/cat":\n	  io.WriteString(res, `<img src="https://upload.wikimedia.org/wikipedia/commons/0/06/Kitten_in_Rizal_Park%2C_Manila.jpg">`)\n   case "/dog":\n	  io.WriteString(res, `<img src="https://upload.wikimedia.org/wikipedia/commons/6/6e/Golde33443.jpg">`)\n   }\n}\n\nfunc main() {\n\n   var h myHandler\n   http.ListenAndServe(":9000", h)\n}		*使用第三方 gin 开发 restful api			package main\nimport (\n   "github.com/gin-gonic/gin"\n   "net/http"\n)\nfunc main() {\n   router := gin.Default()\n   router.GET("/user/:name", func(c *gin.Context) {\n	  name := c.Param("name")\n	  c.String(http.StatusOK, "Hello %s", name)\n   })\n   router.POST("/form_post", func(c *gin.Context) {\n	  message := c.PostForm("message")\n	  nick := c.DefaultPostForm("nick", "anonymous")\n	  c.JSON(200, gin.H{\n	     "status":  "posted",\n	     "message": message,\n	     "nick":    nick,\n	  })\n   })\nrouter.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")\n}		*HTTP 状态码			200  ok			300 重定向			400 资源未找到			500 服务器内部错误###	7 内存管理		*显示内存地址			func main() {\n   a := 43\n   fmt.Println("a - ", a)\n   fmt.Println("a's memory address - ", &a)\n   fmt.Printf("%d \\n", &a)  //整数显示\n}		*使用内存地址，移动数据的内存地址			const metersToYards float64 = 1.09361\nfunc main() {\n   var meters float64\n   fmt.Print("Enter meters swam: ")\n   fmt.Scan(&meters)\n   yards := meters * metersToYards\n   fmt.Println(meters, " meters is ", yards, " yards.")\n}###	8，指针		*使b指向存储int的内存地址的指针，b is of type "int pointer"			func main() {\n   a := 43\n   fmt.Println(a)\n   fmt.Println(&a)\n   var b = *&a  //43\nvar c = &a  //0xc00000a0c8\n   fmt.Println(b)}		*是类型的一部分，*将只会原值，而不是地址			var b = *&a\nfmt.Println(b)				结果仍然是 43		*引用取消 dereferencing 与 重新赋值：传递地址更高性能，因为不必传大量的数据			a := 43\nfmt.Println(a)  // 43\nfmt.Println(&a) // 0x20818a220\nvar b = &a\nfmt.Println(b)  // 0x20818a220\nfmt.Println(*b) // 43\n*b = 42        // 指针b , "重新指定值为 42"\nfmt.Println(a) // 42			我们可以传递一个内存地址而不是一堆值（我们可以传递一个引用）			然后我们仍然可以更改存储在该内存地址中的任何内容的值		*当我们传递一个内存地址时，我们也传递了一个值			everything is PASS BY VALUE in go		*使用指针： 传递地址指针，参数值将改变			如果传递参数搭到其他函数做操作，参数值 不会改变				func zero(z int) {\n   z = 0\n}\nfunc main() {\n   x := 5\n   zero(x)  // 参数 传递到 其他函数中 不会改变 参数的值\n   fmt.Println(x) // x is still 5\n}			如果传递参数的 地址 并且 改变传入 指针 原地址的值， 原地址所在的参数值也将改变				func zero(z *int) {\n   *z = 0\n}\nfunc main() {\n   x := 5\n   zero(&x)\n   fmt.Println(x) // x is 0\n}###	9 控制语句		*if-else			else 分支可以没有，但是如果有则必须与if的大括在同一行				b := false\nif food := "Chocolate"; b {\n   fmt.Println(food)\n} else { // else 不能换行\n   fmt.Println("Nothing")\n}			else if # 多重条件判断				if false {\n   fmt.Println("first print statement")\n} else if true {\n   fmt.Println("second print statement")\n} else {\n   fmt.Println("third print statement")\n}			在for循环体中判断				for i := 0; i <= 100; i++ {\n   if i%3 == 0 {\n	  fmt.Println(i)\n   }\n}		*switch			多个case匹配到 swith语句条件需要 1.15版本				switch "Jenny" {\ncase "Tim", "Jenny":\n   fmt.Println("Wassup Tim, or, err, Jenny")\ncase "Marcus", "Medhi":\n   fmt.Println("Both of your names start with M")\ncase "Jenny", "Sushant":\n   fmt.Println("Wassup Julian / Sushant")\n}			case语言可以匹配单个 switch				switch "Jenny" {\ncase "Tim", "Jenny":\n   fmt.Println("Wassup Tim, or, err, Jenny")\ncase "Marcus", "Medhi":\n   fmt.Println("Both of your names start with M")\ncase "Julian", "Sushant":\n   fmt.Println("Wassup Julian / Sushant")\n}			switch无匹配条件				switch {\ncase len(myFriendsName) == 2:   fmt.Println("Wassup my friend with name of length 2")\ndefault:\n   fmt.Println("nothing matched; this is the default")  //将会输出这条default\n}		*循环for: 与C相同， 同时可以当作while用			嵌套循环 				for i := 0; i < 5; i++ {\n   for j := 0; j < 5; j++ {\n	  fmt.Println(i, " - ", j)\n   }			单一条件的for循环				i := 0\nfor i < 10 {\n   fmt.Println(i)\n   i++\n}			无条件for循环，死循环，没有退出机制break				i := 0\nfor {\n   fmt.Println(i)\n   i++\n}			退出机制 break				i := 0\nfor {\n   fmt.Println(i)\n   if i >= 10 {\n	  break\n   }\n   i++\n}			continue 与 break				i := 0\nfor {\n   i++\n   if i%2 == 0 {\n	  continue\n   }\n   fmt.Println(i)\n   if i >= 50 {\n	  break\n   }\n}			可以使用for range 来遍历 map字典 和 slice切片###	10 函数与结构体		*函数			无参数				func test(){\nfmt.Println("test1")\n}			需要参数				func test(name string){\nfmt.Println("test1", name)\n}			在函数参数中定义 将返回哪个参数				func main() {\n   fmt.Println(greet("Jane ", "Doe"))\n}\nfunc greet(fname string, lname string) (s string) {\n   s = fmt.Sprint(fname, lname)\n   return\n}			Sprint同时返回多个参数				func main() {\n   fmt.Println(greet("Jane ", "Doe "))\n}\nfunc greet(fname, lname string) (string, string) {\n   return fmt.Sprint(fname, lname), fmt.Sprint(lname, fname)\n}			可变参数 variadic params: 函数包含一个可变的浮点数 列表参数 func average(sf ...float64) float64 { 				func main() {\n   n := average(43, 56, 87, 12, 45, 57)\n   fmt.Println(n)\n}\nfunc average(sf ...float64) float64 {  //sf 为列表，可变的参数\n   fmt.Println(sf)\n   fmt.Printf("%T \\n", sf)   //显示格式\n   var total float64\n   for _, v := range sf {\n	  total += v\n	  fmt.Println(total, v, "in", sf)\n   }\n   return total / float64(len(sf))   // 返回均值\n}				分片可变参数 slice					func main() {\n   data := []float64{43, 56, 87, 12, 45, 57}\n   n := average(data)\n   fmt.Println(n)\n}\nfunc average(sf []float64) float64 {\n   fmt.Println(reflect.TypeOf(sf))  //类型查看\n   total := 0.0\n   for _, v := range sf {\n	  total += v\n   }\n   return total / float64(len(sf))\n}		*结构体			初始化结构体及字段 #相当于定义类和属性				type person struct {\n   first string\n   last  string\n   age   int\n}					实例化和赋值：p1 := person{"James", "Bond", 20}p2 := person{"Miss", "Moneypenny", 18}\nfmt.Println(p1.first, p1.last, p1.age)\nfmt.Println(p2.first, p2.last, p2.age)			函数/方法：定义方法需要在结构体后，然后在func后添加括号 指定哪个结构体的方法				func (p person) fullName() string {\n   return p.first + p.last\n}			嵌入式类型embedded types			结构体指针：允许代码直接对结构体实例化				type person struct {\n   name string\n   age  int\n}				p1 := &person{"James", 20} //在main函数中直接 指向结构体地址 使用			结构体定义时 属性带tags				type person struct {\n   First string\n   Last  string `json:"-"`\n   Age   int    `json:"wisdom score"`\n}		*序列化			json.Marshal 序列化encoding/json				p1 := person{"James", "Bond", 20}\nbs, _ := json.Marshal(p1)			json.Unmarshal 反序列化				json.Unmarshal(bs, &p1) //反序列化		*接口 interface			接口 使得 有多个相同 目标的 结构体 和函数 可以 简单的方式 被访问				func (c circle) area() float64 {				func (s square) area() float64 {			排序 import "sort"  #排序都是基于原对象的操作，不返回新的对象				s := []string{"Zeno", "John", "Al", "Jenny"}\nsort.Strings(s)  //字符串排序				sort.Sort(sort.StringSlice(s)) //分片排序				sort.Sort(sort.Reverse(sort.StringSlice(s))) //逆序				n := []int{7, 4, 8, 2, 9, 19, 12, 32, 3}\nsort.Sort(sort.IntSlice(n)) //int 分片排序				sort.Sort(sort.Reverse(sort.IntSlice(n))) //int切片逆序 排序				sort.Ints(n)  //升序			空接口				type vehicles interface{}				空接口可以倒接 多个结构体实例					rides := []vehicles{prius, tacoma, bmw528, boeing747, boeing757, boeing767, sanger, nautique, malibu} \nfor key, value := range rides {\nfmt.Println(key, " - ", value)\n}					接口 参数 可 接受任何类型						func specs(a interface{}) {\n   fmt.Println(a)\n} //参数可以传入  结构体 实例				任何类型的分片					critters := []interface{}{fido, fifi, shadow}\nfmt.Println(critters)  //fido, fifi, shadow 都是动物的 子类实例，接口可以直接分片它们			方法集：method sets				 ###	11 数据类型 有不同大小的区别		*整数			具有不同大小的数据类型外，诸如整数之类的类型也有两种基本类型：int64有符号整数signed，uint64无符号整数unsigned			byte				以数字表示字符串			rune				可以是一个字节或4个字节，表示unicode字符		*浮点数			var f64 float64 = 3.1415926		*布尔			true, false			将布尔值存于变量				myBool := 5 > 8		*数组 Arrays			coral := [3]string{"blue coral", "staghorn coral", "pillar coral"}			var x [3]int  # 创建一个包含3个元素的数组，默认全部为0  [0 0 0]		*切片 slices			slices 没有足够的内存来存储新项目，它将根据需要从系统请求更多内存。\n因为可以在需要时扩展切片以添加更多元素，所以它们比数组更常用			数据类型的前面是一个方括号[]\n，并且在后面是大括号，之间具有值{ }				[]int{-3, -2, -1, 0, 1, 2, 3} # int类型的切片				[]float64{3.14, 9.23, 111.11, 312.12, 1.05} # 浮点类型的切片				[]string{"shark", "cuttlefish", "squid", "mantis shrimp"} # 字符串类型的切片			append: 新增项目到切片 slices				append关键字将一个项目添加到我们的切片中。以下命令会将的字符串值添加seahorse到切片中： seaCreatures = append(seaCreatures, "seahorse")			取切片的下标				xs := []int{1, 3, 5, 7, 9, 11}\nfor i, value := range xs {\n   fmt.Println(i, " - ", value)\n}			删除切片元素				mySlice = append(mySlice[:2], mySlice[3:]...)				mySlice[:2] # 留下前两个元素				mySlice[3:] # 切除前三个元素			直接对切片的元素做运算				mySlice := make([]int, 1)\nmySlice[0] = 1\nmySlice[0]++    //直接对切片元素 做运算				分支主题		*map # 一种hash结构，可以做字典用			创建一个map				var myGreeting = make(map[string]string)			判断map是否为空				myGreeting == nil			简写赋值				myGreeting := map[string]string{\n   "Tim":   "Good morning!",\n   "Jenny": "Bonjour!",\n}				添加值					myGreeting["new"]="newvalue"				更新					myGreeting["new"]="newvalue1"				删除					delete(myGreeting, "new") # 一般情况要操作的key都放后面					当删除一个不存在的 键时，不会报错			长度len				分支主题			判断是否存在某个键				if val, exists := myGreeting[9]; exists {} else {}		*字符串 string			反引号` 或双引号" 来定义			转义 				a := "Say \"hello\" to Go!"			字符串格式打印				a := "Hello, 世界"    for i, c := range a {\n	    fmt.Printf("%d: %s\\n", i, string(c))  # c的指定格式				fmt.Println("length of 'Hello, 世界': ", len(a))  # 默认格式			int类型数字转 对应的字符				string(65) # 将返回A				fmt.Println(string(0)) # 将返回空格		*符号数字：runes are number， 单引号定义			letter := 'A'\nfmt.Println(letter)\nfmt.Printf("%T \\n", letter)  # 65  int32 的 65 			字符串转 符号数字， 只能一个一个的转				letter := rune("A"[0])			hash桶 hashBucket # 将字符串与int类型 传入一个参数并做运算				func hashBucket(word string, buckets int) int {\n   letter := int(word[0]) + int(word[1])\n   fmt.Println("letter % buckets", letter, buckets)\n   bucket := letter % buckets\n   return bucket\n}				调用 					n := hashBucket("Go", 12)\nfmt.Println(n)			remained bucket selected： 桶剩余值选取,按字符串下标序列，访问字符串的 字符				word := "Hello"\nletter := rune(word[0])\nfmt.Println(letter, word[0], string(letter), word[1], word) # 输出值： 72 72 H 101 Hello				当直接使用序号访问 字符串的某个字符时，默认返回的是 rune值				在go中每个中文字符，占 3个字节长度		*hashtable： hash表 			http_get # hash桶 获取数据				res,err := http.Get("url")\nif err != nil {  // 如果有报错\n	 log.Fatal(err) \n}			hash键值桶				1，获取数据\n2，扫描页面\n3，完成后关闭扫描\n4，设置分割程序\n5，创建 hash键值桶\n6，创建切片(键值对桶)以容纳单词，\n7，遍历桶中的值\n8，打印桶数据				创建键值对桶：buckets := make(map[int]map[string]int)				创建切片：buckets[i] = make(map[string]int)					遍历扫描体：// 遍历扫描体for scanner.Scan() {\n   // 赋值给 word\n   word := scanner.Text()\n   // 获取hash桶\n   n := hashBucket(word, 12)\n   // 更新 hash 键值\n   buckets[n][word]++\n}				打印桶中词					// 打印桶中 单词\nfor k, v := range buckets[6] {\n   // 出现次数， 单词本身\n   fmt.Println(v, " \t- ", k)\n}				均匀桶函数					func hashBucket(word string, buckets int) int {\n   var sum int\n   for _, v := range word {\n	  sum += int(v)\n   }\n   // 均匀桶\n   return sum % buckets\n}###	文件流		os.Open("text.txt")		_, err := os.Open("no-file.txt")\nif err != nil {\n   fmt.Println("err happened", err) //错误处理，打印 不带日期		带日期时间			log.Println("err happened", err)\nlog.Fatalln(err)		写日志 log.SetOutPut			程序包日志实现了一个简单的日志记录程序包...写入标准错误并打印每条记录的消息的日期和时间...致命函数在写入日志消息后调用os.Exit（1）... Panic函数调用panic写入日志消息后。			log.Println调用Output来打印到标准记录器。参数以fmt.Println的方式处理。		捕获打开文件的错误			_, err := os.Open("no-file.txt")\nif err != nil {\nlog.Fatalln(err)   // 捕获打开 文件的错误   //    panic(err)\n}###	错误处理		用户抛出自定义错误 import "errors"			return 0, errors.New("norgate math: square root of negative number")		参数设置为 固定 错误			var ErrNorgateMath = errors.New("norgate math: square root of negative number")			ErrNorgateMath := fmt.Errorf("norgate math again: square root of negative number: %v", f)		抛出的错误中含有 参数			return 0, fmt.Errorf("norgate math again: square root of negative number: %v", f)		自定义错误类型 NorgateMathError			nme := fmt.Errorf("norgate math redux: square root of negative number: %v", f)\nreturn 0, &NorgateMathError{"50.2289 N", "99.4656 W", nme}			type NorgateMathError struct {\n   lat, long string\n   err       error\n}