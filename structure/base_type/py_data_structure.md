# 概述
    主要作用，分析待处理 **对象的特征**，各处理对象之间的关系
    数据结构是一门讨论"描述现实世界实体的数学模型(非数值计算)"及其上的操作在计算机中如何表示和实现
    
    1，抽象一个适当的数学模型
    2，设计一个解此数学模型的算法
    3，调试直到解答完毕
    
## 一，基本概念和术语
    1，数据data
        所有能输入计算机并被程序处理的符合的总称
        包括不限于整数，实数，字符，声音，图像，图形
    2，数据元素data element
        数据的基本单位，元素，记录，结点，顶点
        在计算机程序中通常作为一个整体考虑和处理
        一个数据元素可以由一个或多个数据组成
        
    3，数据项data item
        数据不可分割的最小单位，如姓名，年龄
        
    4，数据对象data object
        由性质相同的数据元素组成的集合
        数据对象是数据的一个子集
        如4个整数组成的数据对象，有限集
            lis1 = {1,2,3,4}
        又如由正整数组成的数据对象无穷集
            lis2 = {1,2,3...}
    5, 数据结构data structure
        相互之间存在一种或多种特定关系的数据元素的集合，这个关系称为结构
        四类基本关系:
            集合
            线性结构
                数据元素一对一的相互关系
            树形结构
                数据元素一对多的相互关系
            图状结构
                数据元素多对多的相互关系
    6, 数据的逻辑结构
        各数据元素之间的逻辑关系，逻辑分类
        数据结构，分为线性，非线性
            
    7, 存储结构
        数据结构在计算机存储器中的映像(mapping)
        存储结构也称 存储表示，物理结构，物理表示
    
    8, 数据类型
        原子类型(int,char,float等)
        结构类型(数组，结构，联合体)
    9, 抽象数据类型(Abstract data Type)
        与计算机的实现无关的数据类型
        形式定义
        ADT抽象数据类型名
        {1,数据对象
        2，数据关系，一个或多个关系
        3,一组基本操作/运算}
        
## 二，如何构建一个数据结构？
    1，分析问题的 具体操作对象
    2。找出对象间的关系，并用数学语言描述
    
### 算法加数据结构 = 程序设计
    算法是处理问题的策略，数据结构是给出问题的数学模型
    程序设计是编织出用计算机处理问题的指令


## 三，基本数据结构
    四种数据逻辑结:
        集合(数据元素没联系，只是同类型)，线性(数据最多一个前驱一个后继)，树形(数据元素一般一个前驱多个后继)，图形(数据元素之间联系一般没有限制)。
    线性结构
        线性表，栈，队列，双队列，数组，字符串
        例如:
            图书特征索引，
            本例中的
            数据: 书目信息
            结构: 线性结构--顺序关系
            操作对象: 图书的特征，编号，书名，作者，出版日期
            对象间关系: 按某一索引项的线性关系排序，如编号
            
    非线性结构
        树，二叉树，图，网，堆，散列表(Hash)
        堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆
            1，堆通常是一个可以被看成一颗树的数组对象，有性质如下:
                堆中某节点值总是不大于或不小于其父节点的值
                堆总是一颗完全二叉树
                将根节点最大的堆叫做最大堆或大根堆，根节点最小的叫最小堆，小根堆
            2，堆是在程序运行时申请内存，动态分配内存，对其访问和对一般内存访问没有区别
            3，堆是应用程序在运行时请求操作系统分配给自己内存，一般是申请/给予过程
            4，堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(后进先出)
        例如:
            二叉堆，斐波那契堆
            人机对弈棋盘
            数据: 棋盘格局
            结构: 层次关系--树结构
        例三:
            五叉路口交通管理
            数据: 交通线路
            结构: 网状结构 -- 图结构
            问题的转换和抽象
            可以同时通车的道路对应的顶点染 相同的颜色
            有线段相连的顶点染不同颜色，使用颜色数尽量少
            
            需要满足:
                顶点的颜色与交通灯的颜色相对应
       
### 定义
    数据结构可以是数值类也可以是非数值类的
### 递归定义
    递归定义是数理逻辑和计算机科学用到的一种定义方式，使用被定义对象的自身来为其下定义（简单说就是自我复制的定义）。
    递归定义(recursive definition)亦称归纳定义，一种实质定义，指用递归的方法给一个概念下的定义。
### 特性

### 运算
    
    数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。
    一般有以下几种常用运算
    检索
        在数据结构中查找满足一定条件多节点，一般是给定一个字段多值，找具有该字段值的节点
    插入
        在数据结构中增加新的节点
    删除
        把指定节点从数据结果中删除
    更新
        改变指定节点一个或多个值
    排序
        把节点按某种指定顺序重新排列，递增或递减
    
### 算法
    1,定义:
        求解一个特定问题的指令的有限序列
    2, 好算法的特征
        有穷性
            有跳出和终止
        确定性
            指令没有二义性
        可行性
            算法操作都是已经实现的基本运算执行有限次来实现
        输入
            有0各多个输入
        输出
            有至少一个输出
    
    3, 分类
    查找算法
        顺序，折半，分块，哈希，二叉排序树
    排序算法
        直接插入，堆排序，2-路归并，快速排序等
    
    算法设计要求
        正确性
            语法，对各种异常的处理
        可读性
            便于交流和维护
        健壮性
            异常输入的处理
        高效与低存储量
            
    算法分析
        主要任务
        目的  
        
    算法描述工具:
        1, 自然语言
        2，程序设计语言
        3，流程图
        4，伪码语言
        5，类C
    
    4, 算法时间复杂度
        算法或程序中基本操作或语句重复执行次数的总和
        n为求解的问题规模，基本操作或语句执行次数的总和称为语句频度f(n)
        时间复杂度记为: T(n)
        
        T(n) = O(f(n))  #执行时间为f(n)
        
        4.1 常见的时间复杂度
        O(n) 线性阶，线性数量级
        O(n**2) 平方阶，平方数量级
        
        O(1), O(log_2_n), O(n), O(n*log_2_n), O(n**3), O(2**n)
        O(1)<O(log_2_n)<O(n)<O(n*log_2_n)<O(n**3)<O(2**n)
    
    5, 算法空间复杂度
        执行算法所需的存储空间大小
        S(n) = O(f(n)), n为问题规模
        存储空间，寄存指令，常熟，变量，输入数据，对数据进行操作的工作单元。实现计算所需空间
        

## 四，存储结构和实现
    存储节点 ？
        存储结点就是数据结点的存储映像，按照存储结构类型不同，这个存储结点中除了本身的数据元素以外，也许还存放有数据元素的关系
    存储结构是 数据结构在计算机存储器中的映像(mapping)
    存储结构也称 存储表示，物理结构，物理表示
    选择存储结构
        4.1 顺序存储结构(向量，一维数组)
        线性表 L = ('A','B','C','D')
        4.1 非顺序存储结构(链接表)
        单链表，分配不一定连续的空间，存放数据的空间顺序可任意
        链接、索引、散列

## 五，应用
    基本应用
    
    综合应用

## 六. 线性表的定义和操作
    6.1, 逻辑结构定义
    
    由n>=0各数据元素(a1,a2...)构成的有限序列
    记为: L = (a1,a2...an)
    顺序实现或链式实现
    
    6.2,线性表的特征
        a_i-1在 ai的前面， a_i-1 是 ai的直接前驱， a_i 是 a_i-1的直接后继
        a1没有前驱(即首元素没有前驱)
        an没有后继(即尾元素没有后继)
        其他每一个元素都有一个前驱和后继
    6.3,顺序存储结构的寻址公式
        根据线性表首地址来计算其他元素的存储地址
        
    6.4,插入算法实现举例
        有n个元素，在 n/2处插入一个元素，n/2之后的所有元素都会后移
        实现方法
        1，用指针指向被操作的线性表，静态分配
        2，用引用参数表示被操作的线性表
        3，动态分配线性表空间，用引用参数表示被操作的线性表
     6.5, 插入，删除元素的次数分析
     6.6, 顺序存储结构
        优点
            随机存储结构，任何元素存储时间是一个常数，速度快
            结构简单
            不使用指针
        缺点
            插入和删除元素需要移动大量元素，消耗大量时间
            需要一个连续的存储空间
            插入元素可能发生溢出
            自由区的存储空间不能被其他数据共享
     
     6.7 静态链表存储结构 
         结构数组的第一个元素可看成是头结点，其指针域指向的是链表的第一个结点。
         这种存储方式仍需事先分配一个较大的空间，但是在线性表插入或者删除数据时就不需移动数据了，只要指针位置即可
         ** 与动态链表区别
            异：静态链表是数组实现的，是顺序存储结构，在物理地址上是连续的，而且需要预先分配大小。
            动态链表是用内存申请函数（malloc）动态申请内存的，所以每个节点的物理地址是不连续的，要通过指针来顺序访问。

            同：在插入或者删除数据时只需修改指针即可，不用移动元素
     6.8 类型:
            
            1，单链表
                head 头指针，head=Null，为空表，否则为非空
                data-next (next称为指针域/链域)
            设计单链表类型如先进先出，后进先出
            
            插入
                在单链表指定位置插入新元素
                输入: 头指针L，位置i，数据元素
                输出: 成功返回OK，否则Error
                
            2，循环链表 
                非空循环链表(带表头)
                    tail 尾指针指向表尾结点
                    tail - >next指向表头结点
                    tail - >next - >next指向首结点
                空循环链表(带表头) 只设尾指针的循环链表
                    tail -> next == tail
                两个循环列表首尾相连
                    列表1的tail指向列表2的首元素
                    列表2的tail->next 指向列表1的 head
                    
            双向链表
                数据域，指针域
                前驱  <-->a1<---> 后继
                非空表
                空表
                删除节点需要考虑更多，
            双向循环链表
                空表
                L -> next==L->prior==L
                非空表
            
            
## 七，栈和队列
    线性表 L = (a1,a2...an)
    可在任意第i个位置 **删除|插入** 新元素
    受限数据结构
    插入和删除受限制的线性表
        栈(stack)
        队列(queue)
        双队列(deque)
        
    7.1, 栈定义和操作
        栈: 限定在表尾做插入，删除操作的线性表
        也称 后进先出表，LIFO表，反转存储器，地窖，堆栈
        (a1,a2...an)  
        栈底 a1  表头，不允许插入，删除的一端
        栈顶 an  表尾，允许插入，删除的一端
        进栈
            或称为: 入栈，推入，压入，push
            插入元素,默认an+1(进栈)
        出栈
            或称为: 退栈，上托，弹出，pop
            删除元素，默认删除an(出栈)
        空栈
            不含元素的栈
        
        自由区
            栈中空的位置
        进出原则
           
            后进先出 Last In First Out
    
    
    7.2，栈的基本操作
        1， Initstack(s)  置为空栈
        2， Push(s,e)     元素e 进 栈s
            若s已满，发生**溢出**
            若不能解决溢出，重新分配空间失败，则插入失败
        3， Pop(s,e)   删除栈s的顶元素，并送入e
            若s为空栈，发生 **下溢** (underflow)
            为空栈时，表示某项任务已经完成
        4， Gettop(s,e) 栈s的顶元素拷贝到e
            若s为空栈，结束拷贝
        5， Empty(s)  判断s是否空栈
            s是空栈，返回true，否则返回false
            
    7.3, 栈的存储表示和操作实现
        顺序栈
            用顺序的空间表示的栈
            设计实现方案时，需要考虑的因素
            栈元素和顶指针合并定义一个记录(结构)
            空间分配方案
                静态分配 typedef struct
                    栈元素空间，顶指针，sqstack为结构类型，s为结构类型变量，都需要指定
                动态分配
                    指向栈元素空间，顶指针，栈元素空间大小，相当于maxleng
                    s为结构类型变量
        链式栈
            不带表头节点的单链表
                  
        如何分配存储空间
            动态分配或静态分配
            栈空间范围  s[0, maxleng-1]
            
        如何设置进栈和出栈的标志top
            如top指向栈顶元素或指向栈顶元素上一空单元，作为进栈出栈的依据
        分析满栈的条件，用于进栈操作，
            top顶指针指向顶元素所在位置，进一个元素 top+=1
            先进再加
            若 top == maxlength -1 插入元素发生溢出 overflow
            先加再进
            top == maxlength
            
        分析空栈的条件，用于出栈操作，取出top栈顶元素，再对top -= 1
            先出再减
            若 top == -1，删除元素发生 下溢
         
            先减再出
            top == 0
    
    7.4, 栈的应用举例
        栈常用于，保存暂时不用的数据或存储地址
        数值转换如，给定10进制 1300，转换为8进制
        计算中的数字保存到栈中
        
        实际使用时使用多个栈，如
        操作数栈
        算符栈
        
        一个栈的cpp实现，详细
            //main.cpp   
            int   a   =   0;   全局初始化区   
            char   *p1;   全局未初始化区   
            main()   {   
            int   b;   栈   
            char   s[]   =   "abc";   栈   
            char   *p2;   栈   
            char   *p3   =   "123456";   123456/0在常量区，p3在栈上。   
            static   int   c   =0；   全局（静态）初始化区   
            p1   =   (char   *)malloc(10);   
            p2   =   (char   *)malloc(20);   
            分配得来得10和20字节的区域就在堆区。   
            strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 
            优化成一个地方。   } 
        
    7.10 队列(queue)
        队列及其操作
        定义:
            队列 -- 只允许在表的一端删除元素，在另一端插入元素的线性表
            空队列  不含元素的队列
            队首   队列中只允许删除元素的一端  head front
            队尾   队列中只允许插入元素的一端  rear tail
            队首元素  处于队首的元素
            队尾元素  处于队尾的元素
            进队   插入一个元素到队列中， 又叫 入队
            出队    删除一个队列的元素
            
            又称先进先出表
            First In First Out， FIFO， 排队， queue
        基本操作
            InitQueue(q) --- 初始化，将q置为空队列
            QueueEmpty(q) --- 判断是否空队列
            EnQueue(q,e)  --- 将e插入队列q的尾端
            DeQueue(q,e) --- 取走队列q的首元素 送e
            QetHead(q,e) ---  读取队列q的首元素，送e
            QueueCleaer(q) -- 置q为空队列
         
    
    7.11 双队列(deque-- double ended queue)
        1， 双队列，--- 只允许在表的两端插入，删除元素的线性表
        2， 输出受限队列 --- 只许在表的两端插入，在一端删除
        3，输入受限对象 --- 只允许在队列一端插入，两端删除
        
    
    7.12 链式队列
        用带表头的单链表表示队列
        空队列
        非空队列
        满队列
        结点类型
            存放元素的节点类型
        
            由头尾指针组成的结点类型
                头指针，尾指针，链式队列类型
    7.13 假溢出
        1，置队列长度为6
        2，ABC从左侧入队，
        3，ABC出队
        4，DEFG从右侧入队，
        5，G进队报错，溢出，其实现在ABC已经出队，有空间存储G，但是溢出
        
        解决办法:
            1，移动元素，把 DEF移动到前端
            2，将队列q 当作循环表使用，G 将被放入 队首
            
     7.14 二义性
        1, 增加标识变量
        2, 剩下最后一个单元不使用，避免满队列出现二义性
            进队前测试，r+1 = f，则还剩下一个单元
            Q[0, maxleng-1] 共有maxleng-1个元素
     7.15, 空满队列条件
        满队列 r+1 =f 或 f==0 && r == maxleng-1
        (r+1)%maxleng==f 满队列
        
        出队后 空队列条件 f == r
        
        
     7.16, 后缀表达式与中缀表达式转换
        一种方法如a+b*c + (d*e + f)*g 转换为后缀表达式
        1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b*c) ) + ( ((d*e)+f) *g ) )

        2)将运算符移到括号的后面，变成((a(bc)*)+(((de)*f)+g)*)+

        3)去掉括号，得到abc*+de*f+g*+  
        
                 
## 八，数组与广义表
     8.1 数组
        8.1.1 定义
        一维数组的定义
            在C语言中，一维数组不能直接增加长度，只能把值拷贝到一个新的长的数组中进行操作
                也可以采用动态空间分配间接地实现此功能
            递归定义，是一个定长线性表(a1,a2...an)
            记为 A = (a1,a2...an)
            ai 为数据元素，i为下标 1<=i<=n
        二维数组的定义
            定长线性表(b1,b2...bm)
            bi 为行向量， 1<=i<=m,由m个行向量组成
            Bm*n = [[a11,a12...a1n]
                    [a21,a22...a2n]
                    ...
                    [am1,am2...amn]]
            或者由n个列向量组成
            Cm*n = [[a11  ... 
                     a21
                     ...
                     am1] ...]    
            列向量是行向量的列
        三维数组
            定长线性列表(c1,c2...cp)
            ci = (a1,a2...am) 为定长二维数组
            三维数组D[1..3,1..4,1..2] p=3, m=4 n=2
            
            D3*4*2
            表示有 2 页，每一页有 3*4 二维数组 一个
            
        
        8.1.2 操作   
            InitAyyay(&A, n bound1,...boundn)  # 初始化
            DestroyArray(&A)        # 销毁
            Value(A,&e, index1,...,indexn)  # 检索
            Assign(A, e, index1,...indexn)   # 赋值
        
        8.1.3 实现方式
            顺序表示和实现
            一维数组顺序表示
                数组元素ai 的地址计算公式
                LOC(i) = b+(i-1)L=LOC(1)+(i-1)L
            二维数组顺序表示
                A = (a1,a2...an),b是分配的连续存储单元首地址，L是1个数据元素所占单元数
                LOC(i)为元素ai的存储位置二维数组a[1..3, 1..2]
                以行序为主序的顺序存储方法
                    逐行将数组元素放到数据连续性空间，体现在右边下标先变化，左边的下标后变化
                    1,开空间，明确开多大的空间
                        b为首地址，L为每个元素所占存储单元数
                    2,确定摆放方式，行序为主，还是列序为主 (行序逐行摆放，列序逐列摆放)
                    3,分析寻址方式，
                        # n表示每行几个元素，m 表示每列有几个元素
                        按行摆放时，aij 地址为： #i和j表示 矩阵共有多少行多少列
                        # 具体计算的ij值，查具体情况
                        Loc(i,j) = Loc(0,0) + (n*i +j)*L    0<=i<=m-1, o<=j<=n-1
                                 
                        按列摆放时，aij 地址为  
                        Loc(i,j) = Loc(0,0) + (m*j+i)*L
                                 = b+(m*j+i)*L  0<=i<=m-1, o<=j<=n-1
                以列序为主序的顺序存储方法
                    逐列将数组元素放到数据连续性空间，体现在左边下标先变化，右边的下标后变化
                    其他基本思想与行序相同
                    
            三维数组的顺序表示
                A[1..,0..n-1]，行序优先，列序优先
            
            矩阵的压缩存储
                将矩阵的元素按照某种分布规律存储在较小的存储单元中
                1,n阶对称矩阵
                    A3x3 = [[1,2,3]
                            [2,3,4]
                            [3,4,5]]
                    aij = aji  1<=i, j<=n
                上三角即 135 对角线的右上部分
                下三角即 135 对角线的左下部分
                
                下三角元素aij 满足i>=j，
                对称矩阵需要存储的数据元素个数 = 1+2+..+n = n(n+1)/2
                
                2, 压缩矩阵位置计算
                设aij在下三角 i>=j
                因: 第1～i-1共有元素 1+2+3+...(i-1)=i(i-1)/2 个
                ai1~aij有j个元素， 
                得: aij序号为k=i(i-1)/2 +j
                
                有公式如下
                该公式为在SA中的映象函数，下标转换公式
                    k = {i(i-1)/2 +j i>=j
                         j(j-1)/2+i  i<j} # 二选一
                或   
                    A[i,j] = {SA[i(i-1)/2 +j]  i>=j
                             SA[j(j-1)/2 +i]  i<j}
                 
                三对角矩阵
                    A5x5 = [[1,2,3,0,0]
                            [2,3,4,5,0]
                            [3,4,5,6,7]
                            [0,5,6,7,8]
                            [0,0,7,8,9]] 
                    1，元素aij 在三对角的条件 |i-j|<=1
                    2, 三对角的需要保存的元素个数  3n-2
                    
                    存储方式
                        行序为主
                            顺序存储非0元素到 SA[1..3n-2]
                        列序为主
                            顺序存储非0元素到 SA[1..3n-2]
                        那么任意三对角元素aij， 在SA中的序号
                            k = (3*(i-1)-1) + (j-i+2) = 2i+j-2
                            A[i,j] = {SA[k]  |i-j| <= 1
                                      0   其他}
                稀疏矩阵的压缩存储
                    定义:
                        非零元素个数远小于矩阵元素总数
                    压缩存储方法:
                        三元组表
                        十字链接表
                        行逻辑链接顺序表
                    三元组表，稀疏矩阵M及其转置矩阵T
                        
                    稀疏矩阵M，(6,7)行列数，非零元素7
                        M6x7 =[[0,0,0,1,0,0]
                            [0,0,1,0,0,93]
                            [2,0,0,1,0,0]
                            [0,0,0,0,0,0]
                            [0,0,21,0,0,89]] 
                    c语言定义三元组顺序类型
                    # define MAXSIZE 10000
                    typedef struct {
                        int  i,j; //非零元行，列下标
                        ElemType e;
                        } Triple; 定义二元组
                    typedef struct {
                        Triple  data[MAXSIZE+1];
                        int mu, nu, tu;
                        } TSMatrix; 定义三元组顺序表
                    TSMatrix M;
                十字链接表
                    M =  {25,0,0,64
                          0,-8,0,0
                          20,0,0,0}
                当要进行矩阵的加、减、乘等运算时，有时非零元素的位置会发生很大的变化，三元组表位保持以行或列序为主而大量移动元素，
                    十字链表就比较灵活，它在三元组表的基础之上（元素e、行row、列col），多了两个指针域down和right（名称随意），
                    right指向同一行中的下一个非零元素，down指向同一列的下一个非零元素

        8.1.4 转置矩阵算法
            根据M的三元组顺序表得到T的三元组顺序表
            void TransMatrix(TSMatrix &T)
            T.mu=M.nu;T.nu=M.mu;T.tu=M.tu;
            if(T.tu)
            {
            q=1;  #// 指向T写时的位置
            for(col=1;col<=M.nu;++col)  #//扫描M的三元组表M.nu次
                for(p=1;p<=M.tu;++p)   #//扫描M的长度为M.tu的三元表
                    if(M.data[p].j==col)
                        {T.data[q].i=M.data[p].j;
                        T.data[q].j=M.data[p].i;
                        T.data[q].e=M.data[p].e;
                        q++;}   
            }       # 时间复杂度 O(M.nu*M.tu)   
            
            改进算法
            # num 用户存储初始非零元素的 位置和个数，初始算法时间复杂度 O(M.nu)
                计算个数算法复杂度 O(M.tu)
            # cpot  初始算法时间复杂度 O(M.nu)
            void TransMatrix2(TSMatrix &T)
            T.mu=M.nu;T.nu=M.mu;T.tu=M.tu;   
            if(T.tu)
            { for(col=1;col<=M.nu;++col) num[col]=0;
              for(t=1;t<=M.nu;t++) ++num[M.data[t].j];
              cpot[1] = 1;   # 计算数组cpot
              for(col=2;col<=M.nu;col++) cpot[col]=cpot[col-1]+num[col-1];
              for(p=1;p<=M.tu;++p){  # 扫描M三元组表
              col=M.data[p].j;    # 确定当前M元素列号
              q=cpot[col];   # 确定在T的存放位置
              T.data[q].j = M.data[p].i;
              T.data[q].i = M.data[p].j;
              T.data[q].e = M.data[p].e;
              ++cpot[col];  #修改T的当前行下一元素存放位置
              
              } 
            } # 时间复杂度: O(M.nu+M.tu) 空间复杂度:O(M.nu)
            
     8.2 广义表
        8.2.1定义
            也称列表，是 n(n>=0)个元素的有限列表
            记为: LS=(a1,a2...an)
            LS 为表名， n LS的长度
            大写字母表示广义表名称，小写字母表示数据元素
            
            原子:当广义表LS元素是一个数据元素时，这个元素称为原子
            子表: 广义表LS元素 不是数据元素时
            
            非空表:
                表头(head): 称第一个元素a1为LS的表头(head), 表头可能是原子也可能是嵌套的广义表
                表尾(tail): LS中除了表头的其余部分(a2,...,an)， 表尾一定是广义表
                
            空表:
                A = ()空表，长度为0，即 GLsitLength(A) = 0
                A1 = ((), ((),())) # 非空表， GLsitLength(A1) = 2
            表头表尾为空表的广义表
                广义表的表头为空，并不代表该广义表为空表。
                例如：
                广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；
                而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()
                广义表Ls(()); Ls 的元素为1，head(Ls)为空，但是Ls不为空。
                广义表Ls1();表示Ls1为空表。
         8.2.2 特征举例:
                B =(e)   # 长度 GLsitLength(B)=1
                    Head(B) = e, Tail(B) = ( )
                C = (a,b,c)
                    Head(C) = a
                    Tail(C) = (b,c)
                    Head(Tail(C)) = b
                    Tail(Tail(C)) = (c)
                D = (c,f,(d,e))
                    Head(D) = c
                    Tail(D) = (f,(d,e))
                    Tail(Tail(D)) = ((d,e))  # 注意有嵌套广义表
                    
         广义表可以共享子表
         广义表可以递归
         广义表的图形表示
            ☐ 表示原子
            ○ 列表，若有表名，附加表名
            
            F 多层次的图形或树形
                A
                B
                    e
                C
                    a,b,c
                d
         8.2.3 基本操作
            1, InitGLsit(&L)    # 创建空广义表 
            2, CreateGLsit(&L, S)    # 根据S的定义创建广义表
            3, DestroyGLsit(&L)    # 销毁一个广义表
            4, GLsitLength(L)    # 求广义表长度          
            5, GetHead(L)   # 求广义表头
            6, GetTail(L)  # 求广义表尾
            7, GListDepth(L)  # 求广义表深度，嵌套深度
                   D5 = （）
                   GListDepth(D5) = 1
                   D6 = (c,f,d,e)
                   GListDepth(D6) = 1
                   D7 = (c,f,(d,e))
                   GListDepth(D7) = 2
         
         8.2.4  广义表的存储结构
            表中元素有不同结构，一般用链式存储结构
            由于广义表的元素既可以是原子，也可以是广义表，所以有原子结点和列表结点
            原子结点结构如下: 只有两个域
                tag=0       # 标识域
                atom=元素    # 值域
            列表结点结构如下: 3个域
                tag=1       # 标识域
                hp=表头       # 表头指针域
                tp=表尾     # 表尾指针域
            * 共用体(联合) 统一管理广义表的结点类型,C代码如下:
            typedef struct GLNode{
                ElemTag tag;  # 标识域，区分原子结点和表结点
                union {AtomType atom; # 原子结点
                    struct {struct GLNode *hp,*tp;
                        } ptr;  # 表结点
                    }
            }   *Glist;
            
## 九，树和二叉树
    9.0 数据结构分类
        线性结构
            线性表，栈，队列，串，数组，广义表
        非线性结构                        
            树，(堆)二叉树，图，网
    树/层次关系结构的典型实例
        人物家谱结构，社会组织结构，文件目录结构，html文档...
    9.1 定义
        1，树 tree
            树是n(n>=0)个结点的有限集T
            当n=0时，T为空树
            当n>0时,
                1, 仅有一个称为T的根结点
                2, 当n>1时，余下的结点分为m(m>0)个互不相交的有限集T1,T2...Tm
                   每个Ti(1<=i<=m)也是一颗树，称为根的子树
        举例以下为 5 个结点的树
            以下为 三度树示例
            A           -- 一层
                B,b     -- 二层
                C       -- 三层
                D       -- 四层
                
        2，结点的度 degress
            结点的子树 数目
        3，树的度
            常说的 3 度树，表示树内各结点的度的最大值.（结点拥有的子树数称为结点的度）
            
            树中各结点的度的最大值就是**树的度**
            特点：
                树中结点数 = 总分叉数(所有结点的度之和) + 1
                
                3.1 度为1的结点表示有1个出边
                3.2 叶子度为0，所以没有出边
                3.3 边数 = 所有结点的度之和
                3.4 结点个数 = 边数 + 1
                3.5 例
                    树T0的度为4，其中度为1，2，3，4的结点个数分别为4，2，1，1
                    T0的叶子数是多少？
                    根据以上特点 边数m = 1*4+2*2+3*1+4*1 = 15
                    结点个数 n = m+1 = 16 (因为连接m条边，连接的就是m+1个点)
                    所有结点 减去 非叶子结点（度 不为 0）数，剩下的就是度为0的叶子结点
                    叶子结点 ny = n - 4-2-1-1 = 8,有8个叶子结点
                
        4，n度树
            度为n的树
        5，叶子(终端结点)
            度为 0 的结点
        6，分枝结点(非终端结点，非叶子)
            度不为0 的结点
        7，双亲(父母 parent) 和孩子(child)
            若结点C是结点P的子树的根，则称P是C的双亲，C是P的孩子 child
        8，结点的层 level
            规定树T的根的层为1，其余任一结点的层等于其双亲的层加1
        9，树的深度 depth，高度
            树中各结点的层的最大值
        10，兄弟 sibling
            同一双亲的结点之间 互为兄弟
        11，堂兄弟
            同一层号的 结点互为 堂兄弟
        12, 祖先
            从树根到某结点所经分 枝上的所有结点，为该结点的祖先
        13，子孙
            一个结点的所有子树的结点为该结点的子孙
        14，有序树
            任一结点的各颗子数，规定从左到右是有次序的，即不能互换位置
        15，无序树
            任一结点的各颗子数，规定从左到右是无次序的，即可以互换位置    
        16，森林
            m(m>=0)颗互不相交的树的集合
            任何一颗非空树可表示为一个二元祖 Tree=(root,F)
            其中 root为根结点，F被称为子树森林
            F={T1,T2...}
    9.2 树的基本操作
        9.2.1 查找:
        Root(T)                 # 求树的根结点    
        Value(T,cur_e)          # 求当前结点元素值
        Parent(T,cur_e)         # 求当前结点双亲结点
        LeftChild(T,cur_e)      # 求当前结点 最左孩子
        RightSibling(T,cur_e)   # 求当前结点右兄弟
        TreeEmpty(T)            # 判断树是否空
        TreeDepth(T)            # 求取树的深度
        TraverseTree(T,Visit())  # 遍历
            按某种规则访问T的每一个结点一次且仅一次的过程    
        求结点的层号，度
        求二叉树T的深度
        求二叉树T的叶子/非叶子...
        
        9.2.2 插入类:
        InitTree(&T)        # 初始化置空树
            T = {}
        CreateTree(&T,definition)  # 按定义构造树
            哈夫曼树，二叉排序树，平衡二叉树，堆
        Assign(T,cur_e,value)   # 给当前结点赋值
        InsertChild(&T,&p,i,c)  # 将以c为根的树插入为结点p的第i颗子树
        插入一个结点    
        
        
        9.2.3 删除类:
        ClearTree(&T)           # 将树清空
        DestroyTree(&T)         # 销毁树的结构
        DeleteChild(&T,&p,i)    # 删除结点p的第i颗子树
        删除一个结点
        
        9.2.4 转换
            二叉树  <--> 树
            二叉树 --> 平衡二叉树
            
        
    9.3 树的结构与线性结构对比
        线性结构
            第一个数据元素，无前驱
            最后一个数据元素，无后继
            其他， 一个前驱，一个后继
        树型结构
            根结点， 无前驱
            多个叶子结点，无后继
            其他数据元素，一个前驱，多个后继
        
    9.4 二叉树
        9.4.1 定义
            递归定义，二叉树是n(n>=0)个结点的有限集
            或由一个根结点 和两颗分别称为左子树和右子树的互不相交的二叉树组成
        特点
            每个结点至多 二棵子树(不存在度大于2的结点)
            二叉树的子树有左右之分，且其次数不能 任意颠倒
            
        
        9.4.2 二叉树的五种形态
            T1，  空集
            T2    只有根结点
                A
            T3   有根结点和左树
                A
              a1
            T4   有根结点和右树  
                A
                   a2
            T5   有根结点和左右树
                A
              a1  a2
        9.4.3 二叉树和2度树的区别
            二叉树可能有 五种形态，因为包括了结点的 左右方向
            2度树有4种形态
        9.4.4 三个结点不同形态的二叉树 5种
            T1         T2    T3   T4     T5
            A          A     A    A      A
           B  C       B    B         B     B  
                     C       C    C          C
        9.4.5 三个结点不同形态的树 2种
            T1         T2
            A          A
          B   C        B
                       C    
               
        9.4.6 二叉树的性质和特殊二叉树
        1，二叉树第i层至多有2**(i-1) 个结点 i>=1
            可用归纳法证明
        2，深度为k的二叉树的最多有2**k -1 个结点
            叶子的数目 = 度为2的结点数目 +1
            n_0 = n_2 + 1
        3, 二叉树中，终端结点数n_0 与度为2的结点数 n_2有如下关系
            n_0 = n_2 + 1
        
        9.4.6 满二叉树 full binary tree
            深度为 k 且有2**k - 1个结点的二叉树
            
            1，每一层的结点树都达到最大，叶子结点都在第k层
            2，度为1的结点n_1 = 0
            3, n个结点的满二叉树深度=log_2(n+1)
               设深度为k，因 2**k - 1 = n, 2**k = n+1
               所以 k = log_2 (n+1)  # 以2为底 n+1 的对数
        9.4.7 顺序编号的满二叉树 full binary tree
            从根结点起从上到下逐层(层内从左到右)
            对二叉树的结点进行连续编号
            设满二叉树有n个结点，编号1，2,...,n
            特征:
                1，左小孩为偶数，右小孩为奇数
                2，结点i的左小孩是2i， 2i<=n; 结点i的右小孩是2i+1, 2i+1 <= n;
                3，结点i的双亲是 [i/2], 2<= i <=n
                4，结点i的层号 = [log_2 i] + 1 = [log_2(i+1)]  1<=i<=n
                
        9.4.8 完全二叉树(顺序二叉树)
            完全二叉树的叶节点 在树的最底层或-2层
                而且叶节点都尽量靠左方。
            如下T8和T9是形状为深度为3的完全二叉树
            以下为深度为3的满二叉树
                1
              2    3
            4   5 6  7
            
            深度T6和T7， 分别为1和2的完全二叉树, T_5不是完全二叉树
                T6      T7      T_5
                1       1        1
                      2            2
                      
            深度为3的完全(顺序)二叉树
                T8          T9
                1            1
              2   3       2     3
            4   5        4  5 6
            
            定义:
                深度为k 有n个结点的二叉树，
                当且仅当 
                每一个结点都与同深度的满二叉树中编号从1到n的结点一一对应
                
            满二叉树一定是完全二叉树
            但是 完全二叉树不一定是 满二叉树
            哈夫曼树是二叉树，但不一定是完全二叉树
            深度为k的完全二叉树性质
                1， 任意结点，左右子树的深度分别表示为 Lhi 与 Rhi
                    Lhi - Rhi = 0 | 1   # 左深度-右深度 为0，1 表示该结点只有 1个或2个子结点
                    即叶结点只可能出现在层次最大或 第二大的两层上
                2, 完全二叉树结点个数n 满足
                    2**(k-1) - 1 < n <= 2**k -1
                3，结点数为n的完全二叉树，深度为
                    [log_2 n] + 1 = [log_2(n+1)]  # 与满二叉树一致 
                
                4，若对含n个结点的完全二叉树从上到下从左至右进行1到n编号
                    如 树 T1
                      A1      # 从上到下
                  B2      C3    # 从左到右
                 D4 E5  F6      # 从左到右
                上面的二叉树最后一个非终结点编号是多少？
                    # 终结点的左双亲结点 编号/2   
                则对完全二叉树的任意一个编号i的结点
                    1), i=1时，则该结点是二叉树的根，无双亲，
                        否则，编号为[i/2]的结点为其双亲结点，下取整
                    2), 2i>n时，该结点无左孩子
                        否则，编号为2i的结点为其左孩子的结点
                    3), 2i+1>n, 则该结点无右孩子结点
                        否则，编号为2i+1的结点为其右孩子结点
        9.4.9 二叉树的存储结构
            1，顺序结构
                使用一维数组存储完全二叉树
                # define MAX_TREE_SUZE 100   # 二叉树最大结点数，包括二叉树中的空位置，需要用0占位
                typedef TElemTyoe SqBiTree[MAX_TREE_SIZE]  #0号单元存储根结点
                SqBiTree bt;
                如上 T1的顺序存储结构
                    ACDBEF //
                    012345 6
                
            1.1 顺序存储特点
                用一组地址连续的存储单元，以层序顺序存放二叉树的数据元素，结点相对位置蕴含结点之间的关系
                
                如 完全二叉树 T2
                      A1      # 从上到下
                  C2      D3    # 从左到右
                 B4 E5  F6   G7   # 从左到右
                        
                ACDBEFG //
                0123456 7
                
                顺序存储有以下特点:数组从 1 编址，i=3
                bt[i]双亲[3/2] = 1,即在bt[1]中
                其左孩子在bt[2i] = bt[6]中
                其右孩子在bt[2i+1] = bt[7]中    
            1.1.10 一般二叉树
            按照完全二叉树的形式存储，没结点的地方用0表示，表示 '虚拟结点'
            如 一般二叉树 T3
                      A1      # 从上到下
                  B2      C3    # 从左到右
                 D4 0   0   G7   # 从左到右
            
            T3的顺序存储结构            
                ABCD00G //
                0123456 7        
            1.1.11 右单支树
            T4 右单支树
            A 1
              B 3
                C 7
                  D 15        
            
            T4顺序存储
            A0B000C000 0 0 0 0 D
            123456789101112131415    
            1.1.11  顺序存储特点
                1，浪费空间
                2，插入删除不方便
            
            2，链式存储结构
                二叉链表  1child-data-rchild
                二叉树链式存储，也称为左孩子右兄弟存储结构
                 （ _表示有左孩子指针,^表示没有右孩子）
                A  --- >  _ A ^
               B --- >  _ B ^
              C --- >  _ C ^
             D  --- >  ^ D ^
             
             优点 1，不浪费空间，2插入删除方便 
            
            3，二叉链式存储
                含n个结点的二叉链表中，有n+1个空链域
                证明：
                    有n-1个结点有链引入，所以非空链域数为 n-1 
                    有n个结点有2n个链引入，所以空链域数为 n+1 
               T5 二叉链表     
                _ A _
            _B_       _C_
          ^D^  ^E^       _F^
                       ^G^  
                 二叉树的层次遍历
                    1，使用队列 数据结构
                    2，访问根结点，并归入队
                    3，队列不为空，重复下列操作
                        3.1, 从队列取出一个结点
                        3.2, 若其有左孩子，访问左孩子，并归入队列
                        3.3, 若其有右孩子，访问右孩子，并归入队列
                              
            4，三叉链表（二叉链表基础上增加了双亲指针）    
                parent-1child-data-rchild
             二叉树T6如下：
                A
             B    C
            D E     F
                   G
            T6的三叉链表为：(&表示双亲指针，_表示有孩子，^表示没有这一方的孩子)
                &_ A _
            &_B_       &_C_
          &^D^  &^E^       &_F^
                       &^G^ 
                       
          问题:
          1，含n个结点的二叉链表中，有n+1个空链域
          注意树 和链表的关系: 
            树是数据结构，二叉链表是数据的存储结构
            1.1, n个结点有几个链域，  2n个
            1.2, n个结点(顶点)树有几边？    n-1个边
            1.3, 边和链域有什么关系？  链域 = 2* 结点数 = 2(边数+1)
          
          2, 含n个结点的二叉树使用三叉链表存储结构，有多少个空链域？？？ （ppt 40页）
            n个结点有 3n 个指针，有n-1个边，有2(n-1)个指针
            所以空链域 k = 3n - 2(n-1) = n+2
          3, 二叉树的叶子数 与 度为2 的结点数有什么关系
             因为二叉数的结点 度数 只能是 0，1，2
             设 二叉数 结点数为 m， 边为a， 度为1的结点数 n1，度为2的结点数 n2
             叶子数为m1， n1+n2+m1 = m
             a = n1+n2+m1 - 1
             同时 边数 也等于 n1 + 2*n2 (因为度为1的结点表示有1个出边)
             a = n1 + 2*n2
             所以
             n1 + 2*n2 = n1+n2+m1 - 1
             叶子数 m1 = n2 + 1
             答:叶子数 等于 度为2 的结点数 +1               
        9.4.10 线索链表  
            为了利用空链域而出现的
            
        9.4.10.1 遍历二叉树
        ~1，遍历 是任何类型均有的操作，
            线性结构而言，只有一个路径(每个结点只有一个后继)
            二叉树，非线性结构，遍历可以选择路径，有'搜索路径'的问题
            
        按某种规则访问二叉树的每一个结点一次且仅一次的过程
            二叉树一次遍历后，使树中结点的非线性排列按访问先后顺序变为**某种线性排列**
        遍历是树结构 插入，删除，修改，查找运算的基础
        ~2，过程
            设 D 为访问根结点，输出跟结点
            L 为递归遍历左子树，R为递归遍历右子树
        9.4.10.1.3，规则
            二叉树T
                A
             B      C
          E    F       D
                      G
            
            二叉树表示算术表达式f()= (A/B)*C*D+E
                +
                  E
              *
                D
            *
              C
          /
            B
        A
        ~3.1，先左后右
            树的遍历过程会访问 双亲结点多次，入栈一次，出栈一次
            递归的实现简明精炼，但是效率低，某些高级语言不支持递归
            ~3.1.1 DLR 先序遍历 (先根，preorder)
                前序遍历（中左右）
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,访问根结点；2,先序遍历根的左子树;3,先序遍历根的右子树
                例1，以上二叉树 T的访问顺序为: A BEF CDG
                例2，算术表达式的先序遍历结果: +**/ABCDE  (前缀表示法，波兰式)
                    
            ~3.1.2 LDR 中序遍历 (中根，inorder)又称非递归算法
                中序遍历（左中右）
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,中序遍历根的左子树;2,访问根结点;3,中序遍历根的右子树
                例1，以上二叉树 T的访问顺序为: EBF A CGD   #这里顺利奇怪，固定从左到右？
                例2，算术表达式的中序遍历结果: A/B*C*D+E  (中缀表示法)
                非递归实现:
             * 空指针也进栈
             1，设置栈S存放所经过的根结点指针信息，初始化S
             2，遇到根结点并不访问，而是入栈
             3，中序遍历它的左子树
                左子树遍历结束后，将根结点指针退栈，并访问根结点
                然后中序遍历它的右子树
             4，当需要退栈时，如果栈为空则结束
             
             此非递归实现的中序算法，栈中结点都没有被访问
             跟先进栈，左孩子紧随其后进栈，右孩子左根出栈后入栈
             每个结点都进一次，出一次栈，且总是访问栈顶元素
             时间复杂度为 O(n)，
             空间复杂度最大O(n) 即<= O(n)
                        
            ~3.1.3 LRD 后序遍历 (后根，postorder)
                后序遍历（左右中） 最后一定为根
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,后序遍历根的左子树;2,后序遍历根的右子树;3,访问根结点
                例1，以上二叉树 T的访问顺序为: EFB GDC A   # 这里顺利奇怪
                例2，算术表达式的后序遍历结果: AB/C*D*E+  (后缀表示法 逆波兰式)
                
            ~3.1.4 层序顺序遍历
                层序遍历算法，循环处理，当孩子为空，空指针不入队列 
                时间复杂度 和 空间复杂度均为: O(n)
                按从上到下逐层，同层从左到右的次序访问各结点
                访问根之后，通过根访问其左孩子，然后右孩子
                采用队列数据结构
                例，算术表达式的层序遍历结果 +*E*D/CAB
            ~3.1.5 应用
                1，创建建立(生成)二叉树的存储结构
                    输入: 带空结点的二叉树的先序序列
                    输出: 二叉树的根指针
                    非递归实现:
                        输入: 各结点的值及其在满二叉树中的编号
                        输出: 二叉树根指针
                2，基于遍历序列构造二叉树
                3，求二叉树的深度(后序遍历)
            问题:
                由一颗二叉树的先序序列和中序序列可唯一确定这颗二叉树
                如果知道先序(或后序) 和中序 遍历结果，是否可以恢复出二叉树？  # 可以
                例1:
                    已知二叉树
                    中序序列 BDCEAFHG
                    后序序列 DECBHGFA
                    则 由后序遍历特征，根结点必然在尾部 A
                    由中序特征，根结点必然在中间，左部为左子树，右部为右子树
                    最后，后序DECB子树，确定B为A的左孩子，根据HGF子串，F为A的右孩子
                     A
                  B     F
                   C      G
                  D E    H  
        ~3.2 先右后左
            DRL 逆序遍历
            RDL 逆中序遍历
            RLD 逆后序遍历
        ~3.3 遍历树度应用(重要)
            * 给定二叉树的先序序列，不能唯一确定一个树结构
            * 给定先序(或后序) 和中序，可以唯一确定一个树结构
            
            例1:创建二叉树
            1，创建建立(生成)二叉树的存储结构
                输入: 带空结点的二叉树的先序序列
                输出: 二叉树的根指针
                非递归实现:
                    输入: 各结点的值及其在满二叉树中的编号
                    输出: 二叉树根指针
            2，基于遍历序列构造二叉树
            3，求二叉树的深度(后序遍历)
            
            例2:求二叉树的深度(基于后序遍历)
            基本思想:受限分析二叉树的深度和它的左，右子树深度之间的关系
            
                     A
                  B     F
                   C      G
                  D E    H 
            创建一个函数
                * 输入二叉树的根结点
                * 输出为二叉树的深度
            函数步骤:
                1,判断二叉树树否为空；
                2,左子树的深度；
                3,右子树的深度；
                4,判断左右子树的大小，返回 大的+1 作为二叉树的深度；(由二叉树深度的定义得来)
                
        9.4.10.2 线索二叉树
        ～2.1 遍历二叉树是按某种规则将非线性结构的二叉树结点线性化
        1，遍历二叉树可得到结点的一个线性序列，在线性序列中，就存在结点的前驱和后继，
            但是在二叉链表上只能找到结点的左孩子，右孩子
        2，二叉树结点没有响应的前驱和后继信息
            结点的前驱和后继只有在每次遍历时动态产生
            能否通过结点的两个链域查找出任一结点的前驱和后继？
        
        ～2.2 二叉链表的特点:
        1，n个结点的二叉链表，
            有 2n个指针域，除根以外，使用 n-1个指针,每个结点被一个指针指向
        2，空指针域数 = 2n - (n-1) = n+1
        线索二叉树:
            利用n+1个空链域存放结点的前驱和后继信息       
            
        例:
              A
          B       E
           C     F
         D      G
              H  K
         
        ～2.3 线索二叉树的定义和特征
        定义:
        有先序序列  ABCDEFGHK，指向该序列中的前驱和后继的指针称为线索
        分析结点结构，在二叉链表中增加Ltag 和Rtag两个标志域
            Ichild  Ltag data Rtag rchild
        考虑结构左子树
            有，则左链域Ichild指示其左孩子 Ltag=0
            否，令左链域指示其前驱 Ltag=1
        考虑结构右子树
            有，则右链域Rchild指示其右孩子 Rtag=0
            否，令右链域指示其后继 Rtag=1 
        整体结构 （思考空二叉树线索链表形态）
            增设一个头结点，令其Ichild指向二叉树的根结点Ltag=0，Rtag=1
            并将该结点最为遍历访问的第一结点的前驱和最后一个结点的后继
            最后用头指针指示该头结点
        ～2.4 空二叉树的线索链表
            只有一个头结点，Ltag=0，Rtag=1，Ichild与rchild都指向头结点自身
            _ 0 _ 1 _      
        * 称以这种BiThrNode(左右指针，左右标志)结点结构 构成的二叉链表 称为二叉树的线索链表
        * 指示前驱和后继的链域为 线索
        * 假设线索的二叉树 称为 线索二叉树
        * 对二叉树以某规则遍历使其变成线索二叉树的过程称为线索化
            # 中序/先序/后序 遍历得到的线索二叉树 称为 中序/先序/后序 线索二叉树
            # 先序 线索二叉树：线索指向先序遍历中前驱，后继的线索二叉树
            # 中序 线索二叉树：线索指向中序遍历中前驱，后继的线索二叉树
            # 后序 线索二叉树：线索指向后序遍历中前驱，后继的线索二叉树   
            # 后序后继线索二叉树：只设指向后序遍历中后继线索的线索二叉树
        ～2.5 线索链表遍历算法 (无需堆栈)
        由于在线索链表中添加链遍历中得到的前驱和后继的信息，从而简化链遍历算法
        对中序线索链表的遍历算法，
            ** 有后继找后继，没有后继找右子树的最左子孙
            中序遍历的第一个结点：左子树处于最左下没有左子树的结点     
            中序线索链表结点的后继：若无右子树，则为后继线索指结点
            否则为对其右子树进行中序遍历时访问的第一个结点
            步骤：
            1，设置搜索指针p
            2，寻址中序遍历的 首结点(最左下角结点) Ltag=0时 表示有左孩子
                p=p->child直到LTag=1(无左孩子，已经到最左下角)首先访问p->data
            3,接着进入该结点的右子树，检查RTag和p->rchild
            4,若该结点的RTag=1（表示有后继线索）则p=p->rchild,访问p->data。重复4直到后继结点RTag=0
            5,当RTag=0时，表示有右孩子，则应该从该结点的右孩子开始p=p->rchild，查找左下角子孙结点，即重复2
        ～2.6 建立线索链表(顺序栈)
        在中序遍历过程中修改结点左，右指针域，保存当前访问结点的前驱，后继信息
        遍历过程中，附设指针pre，并始终保存指针pre指向当前访问的，指针p所指结点前驱
        * 每次只修改前驱结点的右指针(后继)和本结点的左指针(前驱)
        若p->ichild = NULL,则 //p的前驱线索应存p结点的左边
        若pre->rchild = NULL, 则//pre的后继线索应存pre结点的右边
        
        ～2.7 画先/中/后序线索二叉树的线性链表

    9.5 树和森林
        9.5.1 树的存储结构
        有树如下
            A
        B   C    D
           E  F
              G
        双亲表示法/顺序表示法/数组表示法
            便于不便于访问孩子结点
            一维数组存储每个结点，每个单元存储结点的值，和双亲的位置域(-1)
            data   A    B   C   D   E   F   G
            parent -1   0   0   0   2   2   5
            r=0   n=7  # n为树的度
        孩子表示法/单链表示法
            固定/非固定 大小结点格式
            很容易访问一个结点的孩子，访问双亲不容易
            
        孩子链表表示法
        带双亲的孩子链表表示法
            带双亲结点的位置域
        树的二叉链表(孩子-兄弟)存储表示法
            根结点的右指针为空
            左指针表示孩子
            右指针表示兄弟
            左右指针都是空时，为叶子结点
            
        树和森林的遍历
        1，树的遍历
            R
         A  B  C
       D  E    F
             G H K
             
        1.1, 先根遍历，若树为空，则空操作
            1),访问树的根结点
            2),依次先根遍历每颗子树
        上图树的 先根遍历序列: RADEBCFGHK
        1.2, 后根遍历，若树为空，则空操作
            1),依次后根遍历每颗子树
            2),访问树的根结点
        上图树的 后根遍历序列: DEABGHKFCR
        2，森林的遍历
        先序遍历森林(相当于对应的二叉树进行先序遍历)
            森林为空，则空操作，否则
            1),访问第一颗树的根结点
            2),先序遍历第一颗树中根结点的子树森林
            3),先序遍历除去第一颗树后余下的树构成的森林
        中序遍历森林(相当于对应的二叉树进行先序遍历) 
            森林为空，则空操作，否则
            1),中序遍历第一颗树根结点的子树森林
            2),访问第一颗树的根结点
            3),中序遍历除去第一颗树后余下的树构成的森林
        3，树的遍历和二叉树遍历的对应关系
            树       森林      二叉树
          先根遍历   先序遍历   先序遍历
          后根遍历   中序遍历   中序遍历      
           
    9.6 树与二叉树的转换(基于树的二叉链表表示，即存储结构为二叉链表)
        1，将树转换为 二叉树
        加线，在兄弟之间加一连线
        抹线，对每个结点，除了左孩子外，去除其余孩子之间的关系
        旋转，以树的根结点为轴心，将整树顺时旋转 45度
        * 原树中 兄弟关系，变成了双亲与右孩子的关系
        * 树转换为二叉树后右子树一定为空
        
        2，二叉树转换为树
        加线，若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子...所有右孩子与p的双亲用线连起来
        抹线，抹掉原二叉树中双亲与右孩子之间的连线
        调整，将结点按层次排列，形成树结构
        
        3，森林转换为二叉树
        将各颗树分布转换成二叉树
        将每棵二叉树的根结点用线相连
        以第一颗树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构
        规则： F为森林集合，二叉树指代用B = (root, LBT, RBT)
            若 F = [], 则B=[]
            否则，
                由ROOT(T1)对应到root
                由F1=(T11,T12...T1m)对应得到LBT
                由(T2,T3...Tn)对应得到RBT
        
        4，二叉树转换为森林
        抹线，将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立二叉树
        还原，将孤立二叉树还原成树
        
        树的各种操作均对应二叉树来操作完成
        和树对应的二叉树，其左右子树的概念已经改变为 左是孩子，右是兄弟
        转换规则:
            若B=[], 则F=[]
            否则
                由root对应得到ROOT(T1)
                由LBT对应得到F1=(T11,T12...T1m)
                T1=(root,T11,T12...T1m)
                由RBT对应得到(T2,T3...Tm)
    
    9.7 哈夫曼树(最佳树/最优树)及其应用
        最优二叉树(Huffman 树)，特点: 总权和最小,判定过程最优
        9.7.1 路径长度
            从树的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作 路径长度
        9.7.2 树的路径长度 PL
            PL(T) 指代 树 T 的路径长度 
            从树根到每一结点的路径长度之和
        9.7.3 树或二叉树T 的带权路径长度 WPL(就是路由与交换里的 OSPF算法，最短路径优先)
            每个子叶的权与根到该叶子的路径长度的乘积之和，记为 WPL(T)
            WPL = 𝚺(k=1,n)w_kl_k
            n 树T的叶子数目， w_k 叶子k的权
            l_k 树T的根到叶子k的路径长度
            以下为树T1(数字表示叶子的权，没有数字表示权为0)
            A
         B     C6
       D3  E
         F4 G9
            则 WPL(T1) = 3*2+4*3+9*3+6*1 = 51   
        9.7.4 特征:
        当n结点的二叉树为完全二叉树时，PL(T)具有最小值
        当n结点的二叉树为单枝树时，PL(T)具有最大值    
        
        9.7.5 最优树
        在具有n个相同叶子的各二叉树中，WPL最小的二叉树
        完全二叉树并不一定是 Huffman树
        在哈夫曼树中权值大的结点离根近(这样WPL才能最小)
        哈夫曼树不是唯一的，但WPL一定相等
        
        9.7.6 Huffman算法
        1,以权值分布为W1，W2...Wn 的n个结点，构成n颗二叉树T1，T2...Tn
          每棵二叉树Ti 仅有一个权值为Wi的根结点
        2, 在F中选取两棵根结点权值最小的树作为左右子树构造一颗新二叉树
          并且置新二叉树根结点权值为左右子树上根结点的权值之和
          根结点的权值 = 左右孩子权值之和
          叶结点的权值 = Wi 
        3, 从F中删除这两棵二叉树，同时将新二叉树加入F
        4,重复2，3直到F中只含一颗二叉树为止(这个就是Huffman树)
        
        5，实例1: 构造哈夫曼树(哈夫曼算法 加 排序)
        给定权集合{4,5,3,6,10},构造哈夫曼树
        5.1，按权值大小排序 3，4，5，6，10
        5.2，生成森林
            3   4   5   6   10
            T1  T2  T3  T4  T5
        5.3，合并两棵权最小的二叉树，并排序，指代一颗为二叉树
          第一步： 合并 3，4
            7
          3   4  5  6  10
          第二步： 排序
          5   6   7   10
                3   4
          第三步：选择合并，排序
          7   10   11  
         3 4      5  6
          第四步：选择合并，排序
         11    17      
        5  6  7  10
             3 4
          第五步：哈夫曼树
             28
          11    17
         5  6  7  10
              3 4
      
       9.7.7 Huffman编码/最小冗余编码
       ASCII编码/定长编码
       as12： 01100001 01100010 00110001 00110010
                97      98          49      50
       哈夫曼码/不定长编码
       能按字符的使用频度，使文本代码总长度具有最小值
       例2：求哈夫曼编码
       给定有18个字符组成的文本 AADATARAEFRTAAFTER
       1）分析统计
           字符  A D  E F T R
           频度  7 1  2 2 3 3
       2）构造Huffman树
           1 2 2 3 3 7
           按照9.7.6 实例1的步骤: 构造哈夫曼树(哈夫曼算法 加 排序)
           最后得哈夫曼树
              18
         7(A)      11
               5         6
           2(F)  3    3(T) 3(R)
             1(D) 2(E)
         得到的哈夫曼树 叶结点根据权值附上字符，分支标数的哈夫曼树
         
       3）构造Huffman 编码
       
           字符   A   D       E   F   T     R
           频度   7   1       2   2   3     3
           编码   0  1010   1011  100 110  111
       0表示左小孩，1表示结点的右小孩 
       哈夫曼编码的特点：
           任一编码不是其他编码的前缀
           哈夫曼树没有度为1的结点
           有n个叶子的结点，则其共有2n-1 个结点
           哈夫曼编码时，是从叶子走到根；
                译码是从根走到叶子，所有每个结点需要增加双亲指针分量
           实现哈夫曼树时，使用顺序和链式两种 存储结构
       
       4) 译码 
       有哈夫曼树如下
              18
         7(A)     11
              5        6
           2(F) 3  3(T) 3(R)
             1(D) 2(E)
       给定代码序列
       0 0 1 0 0 0 1 1 1 0 1 0 1 0 1 0 1 1 1 10
       翻译为文本
       AAFARADET 
        
## 十 图 Graph
    10.1 定义
    图由顶点集V(顶点(元素)的有穷非空集)和关系集 VR(两个顶点之间的关系集合)组成，
    记为  G=(V,VR)
    10.1.1 分类和概念 
    有向图
        有向图，弧(有向边)，若图G任一两顶点a，b之间的关系为有序对(a,b),即(a,b)∈VR
        * 称(a,b)为从a到b的一条弧/有向边， a 是弧尾， b是弧头，# 这里需要特别注意些
        例1：
        G1 = (V1,E1), V1={A,B,C,D,E}
        E1 = {<A,C>,<A,D>,<C,D>,<B,E>,<E,B>}
        称图G1 为有向图,各结点连接线有方向 
    无向图，边(无向边)
        若图G任两顶点a，b之间的关系为 无序对(a,b),则(a,b)为无向边(边)，
        称该图G是无向图，无向图可简称为图
        * (a,b)表示a，b互为邻接点， a,b依附于a和b，(a,b)与a和b相关联，            
        例1：
        G2 = (V2,E2), V2={1，2，3，4，5，6}
        E2 = {<1,3>,<1,5>,<3,5>,<4,6>}
        称图G2 为图 
    简单图
        在无向图中，关联一对顶点的无向边如果多于1条，则称这些边为平行边，平行边的条数称为重数。
        在有向图中，关联一对顶点的有向边如果多于1条，并且这些边的始点与终点相同(也就是它们的的方向相同)，称这些边为平行边。
        含平行边的图称为多重图，既不含平行边也不包含自环的图称为简单图
    完全图
        有n个顶点和n(n-1)/2 条边的无向图，即每个顶点都与其他顶点直接连接
        如果一个无向图有 3个顶点，3个边，就是完全图
        又如 5个顶点，10条边
    有向完全图
        有n个顶点和 n(n-1) 条弧的有向图，就是有向完全图
        如两个顶点A，B 有2个有向线 A->B, B->A
    网 Network
         边(弧)上加权weight的图
         网可以是有向的也可以是无向的，但是每个边必须有权重
    子图
        图G = (V,G) V是顶点，G是顶点之间的关系
        G1 = (V', G'), V'属于V，G'属于G'， 称G1是G的子图
        也就是说如果一个图A的所有顶点和关系都可以在 图B中可以找到，那么A就是B的子图
    图A
        V1 - V2 - V3  V6
            /  \
          V4 - V5    
    度
        与顶点 x 相关联的边(x,y)的数目，称为x的度，记为TD(x) 或 D(x)
        如图A中， D(V1)=1,D(V2) = 4, D(V4)=D(V5)=2, D(V6)=0
    出度
        以顶点x为弧尾的弧(x,y)的数目，称为x的出度记为OD(x)
        V1 <- V2 <- V3   OD(V1)=0,  OD(V2)=1,  OD(V3)=1
         
    入度
        以顶点x为弧尾的弧(x,y)的数目，称为x的出度记为ID(x)
        V1 <- V2 <- V3   ID(V1)=1,  ID(V2)=1,  ID(V3)=0
    TD(V1) = OD(V1) + ID(V1) =1, TD(V2) = OD(V2) + ID(V2) =2      
    连通图 及连通分量 (无向图G)
        从一个顶点出发，一次深度遍历就可以访问到所有顶点
        遍历所得的生成树或序列理论上是不唯一的，但是可以做到唯一
        
        若顶点vi 到 vj有路径，则称vi和vj是连通的
        若图G 任意两顶点是连通的，则称图G是 **连通图** 
        若图G'是G的一个极大连通子图，则称G'是G的一个**连通分量**         
    强连通图 及强连通分量 (有向图G) 7.4.2
        若在图G中，每对顶点vi，vj之间，从vi到vj且从vj到vi都存在路径，则称G是 **强连通图**
        若图G'是G的一个极大 强连通子图，则称G'是G的一个 **强连通分量**
        (强连通图 是自己的强连通分量)
                 
    生成树             
        设G=(V,E), G'=(V',E'), V=V'，若G是连通图，G'是G的一个极小连通子图，
        则G'是G的一棵生成树, 如下所示。T1.T2.T3都是 T0的连通量
            T0              T1            T2          T3
        A - B - C        A - B - C     A - B - C    A   B - C
         \ / \ /            / \           /          \     /
          E - D            E   D         E - D        E - D
                                    
    10.2 特征
        邻接表和邻接矩阵中 对图对顶点 度的算法时间复杂度并不相同
        如有n个顶点，e个弧的有向图，邻接表作为物理结构，求每个顶点的时间复杂度：
            大部分是O(n+e)是对的，O(n*n)是用邻接矩阵存储时的时间复杂度。
            算法就是遍历每一条边，然后把每条边的终点的入度+1.
            在邻接表中，就是要依次访问每个顶点，然后在每个顶点中依次访问每条边，把这些边的终点的入度+1。
            也就是每个顶点和每条边依次要各访问一遍，所以时间复杂度是O(n+e)。
            在邻接矩阵中，算法需要遍历邻接矩阵的每一个点 ，而邻接矩阵有n*n个点，所以时间复杂度是O(n*n)。
    10.3 操作
        1) CreateCraph(&G,V,VR)   #根据顶点集V 和关系集VR生成图
        2）DestroyCraph(&G)    # 销毁图
        3）Locate(G，u)    # 查找顶点u的位置
        4) GetVex(G,v)    # 读取顶点v的信息
        5) PutVex(&G,v,value) #给顶点v的赋值value
        6) FirstAdjVex(G,v) #读v的第一个邻接顶点
        7) NextAdjVex(G,v,w)   # 读v(相当于w)的下一个邻接顶点
        8) InsertVex(&G, v)  #插入顶点
        9) DeleteVex(&G,v)   #删除顶点
        10)InsertArc(&G,v,w) #插入弧(v,w)
        11)DeleteArc(&G,v,w) #删除弧(v,w)
        
        12)DFSTraverse(&G,visit()) # 深度优先遍历图
        13)BFSTraverse(&G,visit()) # 广度优先遍历图
    * 重点 10.4 图的存储结构
        V1    V4
        / \
      V2   V3
        
        4.1 数组表示法/邻接矩阵(顺序+顺序)
            思想
            图的邻接矩阵存储方式是用两个数组来表示图。
            一个一维数组存储图中顶点信息
            一个二维数组（邻接矩阵）存储图中的边或弧的信息
            * 无向图的邻接矩阵一定对称，有向图的邻接矩阵不一定对称
            
            顶点数组，用一维数组存储顶点(元素)
            如上图 vexs = [v1 v2 v3 v4]
            邻接矩阵--用二维数组存储顶点(元素)之间的关系(边或弧)
            无向图邻接矩阵arcs 其中，1表示有连接，0表示没有
            M=
            [[0 0 1 1
              0 0 0 0 
              1 0 0 1
              1 0 1 0]]
            邻接矩阵arcs i行之和 = 𝚺(j=0,n-1)arcs[i][j]
            邻接矩阵arcs i列之和 = 𝚺(j=0,n-1)arcs[j][i]
            有向图邻接矩阵arcs，1表示出口，0表示入口
            由邻接表可以做以下工作 
                求每个顶点的度 D(vi), 矩阵列宽
                OD(vi),  矩阵行每行的和
                ID(vi)  矩阵列宽 减 矩阵每行的和
            
        4.2 邻接表，逆邻接表(顺序+链式)
            邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。
            因此，找到一种数组与链表相结合的存储方法称为邻接表。
            4.2.1 无向图的邻接表
              为图G的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边
              v0 - v1       V3
              v2           /  \
                          V4  V5
              以上 无向图的邻接表 如下
              序号  头结点数组   表结点单链表
              0     v0 __       1 ^
              1     v1 __       0 ^
              2     v2 ^
              3     v3 __       4 __ -> 5 ^
              4     v4 __       3 __ -> 5 ^
              5     v5 __       3 __ -> 4 ^
              若无向图G有n个顶点和e条边，需要n个表头结点和2e个表结点
              无向图G的邻接表，顶点vi的度为第i个单链表的长度
              
            4.2.2 有向图的邻接表 ↖︎ 
              第i个单链表中的表结点的值为j，表示以顶点vi 为弧尾的一条弧(vi,vj)
              特点:   
                1，若有向图G有n个顶点和e条弧，则需n个表头结点和 e个表结点
                2，有向图G的邻接表，顶点vi的出度为第i个单链表的长度
                3，求顶点vi的入度需遍历全部单链表，统计结点值为i的结点数
                  
            如以下向图 G1                
                A -> B <- C
                ↓  ↗︎     ↙︎ ↘︎
                 D      E ->F
               G1有向图邻接表,只表示出度，如下
               0    A _ -> 1 _ -> 3^
               1    B ^
               2    C _ -> 1 _ -> 4 _ -> 5 ^   
               3    D _ -> 1 ^
               4    E _ -> 5 ^
               5    F ^
            4.2.3 有向网的邻接表
                
                有以下有向网G
                A -5> B <7- C
               4↓ 17↗︎     8↙︎ ↘ 10︎
                 D        E -8>  F
                G的邻接表如下
                         1是序号，5是权值 _为指针
                0   A _ -> 1 5 _ -> 3 4 ^
                1   B ^
                2   C _ -> 1 7 _ -> 4 8 _ 5 10 ^
                3   D _ -> 1 17 ^
                4   E _ -> 5 8 ^
                5   F ^
                
            4.2.4 有向图的逆邻接表
                第j个单链表中的表结点的值为i目标是一条以顶点v1为弧尾的一条弧(vi,vj)
                如上有向图G1, 有以下逆邻接表特征：
                若有向图G有n个顶点e条弧，则需n个表头结点和e个表结点
                有向图G的逆邻接表，顶点vi 的入度为第i个单链表的长度
                求顶点vi的出度，需遍历全部单链表，统计结点值为i的结点数
                序号  头结点数组   表结点单链表
                0       A ^
                1       B _ -> 0 _ -> 2 _ -> 3 ^
                2       C ^
                3       D _ -> 0 ^
                4       E _ -> 2 ^
                5       F _ -> 2 _ -> 4 ^
                                 
            4.2.5 有向图的十字链表
                将邻接表和逆邻接表合并而成的链接表
                1， 每条弧有一个弧结点
                    弧结点 tailvex  headvex hlink tlink
                    tailvex 弧尾的位置， headvex 弧头的位置
                    hlink 指向下一条弧头相同的弧
                    tlink 指向下一条弧尾相同的弧
                2， 每条顶点有一个顶点结点
                    顶点结点 data firstin forstout
                    firstin  指向以该顶点为弧头的第一条弧
                    firstout  指向以该顶点为弧尾的第一条弧
                3，步骤
                    以邻接表为基础，扩展结点树形成岂止结点序号
                    再添加逆邻接表信息 得到十字链表
            4.2.6 (无向图的)邻接多重表
            1，每个顶点有一个头结点
                头结点  data firstedge
                其中  data 顶点信息， firstedge  指向第一条依附于该顶点的边
            2，每条边有一个表结点
                表结点 mark ivex jvex ilink jlink
                其中 mark 标志域，用以标记该条边是否被搜索过
                ivex, jvex 该条边依附的两个顶点在顶点数组的位置
                ilink  指向下一条依附于顶点vi的边
                jlink  指向下一条依附于顶点vj的边
            例: 有图如下
                G                  
            A - B   E
            | / |   |
            C - D   F
            隐含的链接表:
            A -> (0,1) ->(0,2) 
            B -> (0,1) ->(1,2) ->(1,3)
            C -> (0,2) ->(1,2) ->(2,3) 
            D -> (1,3) ->(2,3)
            E -> (4,5) 
            F -> (4,5)
              data     ma  vi  vj  il  jl
            0   A _ -> 0   0   1   _   _  (A,B)
            1   B -  ↗             ↓
            2   C _  -> 0  0   2   ^   _  (A,C)  
            3   D _\    0  1   2   _   _  (B,C)
                    ->  0  1   3   ^   _  (B,D)
            4   E ↘     0  2   3   ^   ^  (C,D)
            5   F  ->   0  4   5   ^   ^  (E,F)
            
        *4.3 重点 图的遍历
            A - B - C
            /\   \ /
           E  F   D
            \/ \
            G - H
            从图G的某定点 vi 出发，访问G的每一个顶点一次且只经过一次的过程
            广度优先用队列，深度优先用栈。简单说明如下：
            广度优先：当一个节点被加入队列时，要标记为已遍历，遍历过程中，对于队列第一个元素，遍历其所有能够能一步达到的节点，如果是标记未遍历的，将其加入队列，从第一个元素出发所有能一步直接达到的节点遍历结束后将这个元素出列。
            深度优先：当遍历到某个节点A时，如果是标记未遍历，将其入栈，遍历它能够一步直接达到的节点，如果是标记未遍历，将其入栈且标记为已遍历，然后对其进行类似A的操作，否则找能够一步直接达到的节点进行类似操作。直到所有能够一步直接达到的节点都已遍历，将A出栈。
            这里使用“能够能一步达到的节点”而非“与其相邻的节点”是考虑到有向图因素。
            手工修改队列和栈就明白了
            4.3.1 图的深度优先搜索 DFS Depth First Search
                A E G F H B D C ...
                不可能顺序  A E C F H B D G  ...
            4.3.2 图的广度优先搜索 BFS Breadth First Search
                从顶点出发，设置访问标记1，顶点入队
                队列非空
                访问与该顶点相邻的并且未被访问的顶点，标记顶点，并使顶点入队                
                循环直到顶点为空
                A E F B G H D C ...
                不可能顺序  A E F B C D H G ...
                
                对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。
                一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小
        4.4 图的连通性问题
            无向图的连通分量
            
            生成树
            从不同的顶点出发会有不同的生成树
            DFS生成树
            BFS生成树
            DFS生成森林
            BFS生成森林
            
            有向图的强连通分量
            在有向图G中，从某个顶点v出发顺着弧的方向，进行深度优先搜索遍历，得到顶点集合V1，
            再顶点v出发，G = (V,VR)  V = V1 交集 V2， VR是V中所有顶点在G中的弧
            逆着弧的方向进行深度优先搜索遍历，得到顶点集合v2，这样得到一个强连通分量
            A <- D      A <- D
           ↓↗ ↖↗ ↗     ↓↗  ↗        C
           B <-  C      B
              G         G1          G2
           从A出发，顺着弧方向得到顶点集合 {A,B,D},逆的弧方向的顶点集合{A,B,C,D}
           交集为 {A,B,D}, 加上他们之间所有弧,得到强连通分量G1
           
        * 重点  4.5 网的最小生成树
        在网 G 的各个生成树中，其中各边的权之和的最小的生成树称为G的最小生成树
        网G          生成树T1 权之和13   生成树T2权之和10   ...
          2            2                2
        A - B        A - B            A - B
       1/    \4          \4          1/  
      C       D      C    D          C    D
       4\   /3       4\  /3           4\ /3
          E            E                E
       通过以上定义可知，T2 为 网G 的最小生成树
          
       MST性质-最小代价生成树（Minimum Cost Spanning Tree)（简称为最小生成树）
            设G=(V,E)是一个连通网，Y是V的一个非空子集。如果边(u,v) 是G中所有一端在U中
            而另一端v在V-U中具有最小值的一条边，则存在一棵包含边(u,v)的最小生成树
            
        * 普里姆prim算法 P51
            选顶点为主
            算法适合边稠密的无向连通网 复杂度: T(n,e)=O(n**2)
            对n个顶点对连通网，初始时，T=(U,TE)，U为一个开始顶点，TE=[]
            以后根据MST性质，每次增加一个顶点和一条边，重复n-1次，U不断增大，V-U不断减小直到为空
            
        * 克鲁斯卡尔(Kruskai)算法
            选边为主
            需要将边按递增次序排列，以供选择
            
            算法适合边稀疏的无向连通网 T(n,e)=O(e log e)
        问题
            1，所有边权均不相同的无向图最小生成树是唯一的
            2，同一个图不同最小生成树的边权重序列相同 
            用反证法证明
               
    10.5 有向无环图及其应用
        一个无环的有向图称为有向无环图(directed acyline graph) DAG图    
            
        * 重点 拓扑排序(物理结构是 邻接表) T(n) = O(n+e)
            AOV网(Activity On Vertex network),以顶点表示活动,弧表示活动之间的优先关系的DAG图
            拓扑排序。
            定义:是有向图的全部顶点的一个线性序列，该序列保持了原有向图中各顶点间的相对次序
            思想:
            1，在有向图中选一个没有前驱的顶点输出(选择入度为0的顶点)
            2，从图中删除该顶点和所有以它为尾的弧(修改其他顶点入度)
            3，有回路的有向图不存在拓扑排序
        关键路径
            路径长度最长的路径称为关键路径(Critical Path)
            AOE网(Activity On Edge)
                
                是一个带权的有向无环图，其中以顶点表示事件，弧表示活动，权表示活动持续时间
                AOE网用来估算工程完成时间时，只有一个开始点(入度为0，标为源点)和一个完成点(出度为0，称为汇点)
            AOE网问题
                完成整项工程至少需要多少时间
                    从开始点到v1的最长路径长度 ve(v1)=0
                    完成点(汇点)的ve(vn)为工程完成所需要的时间
                哪些活动影响工程进度关键 
                    l(i) - e(i)表示 完成活动ai的时间余量 
                    l(i)=e(i)的活动
        
        关键路径算法步骤
            1  初始化各顶点最早发生时间0，从开始点v1出发，按拓扑排序序列求其他各顶点的最早发生时间
            Ve(j) = max{ve(i) + dut(<i,j>)}
            vi为以顶点vj为幅头的所有弧的弧尾对应的顶点
            2  从完成点vn出发，令v1(n)=ve(n)按逆拓扑排序序列求其他各顶点的最迟发生时间
            V1(j)=min{(v1(k)-dut(<j,k>)}
            (vk为以顶点vj为弧尾的所有弧的弧头，对应的顶点集)
            3  求每一项活动ai(vj,vk):
            e(i)=ve(j)  l(i)=vl(k)-dut(ai)
                   
        关键活动
            选取e(i) = 1(i)的活动
            关键活动组成了关键路径，关键路径是图中的最长路径，关键路径长度代表整个工期的最短完成时间，关键活动延期完成，必将导致关键路径长度增加，即整个工期的最短完成时间增加。
            关键路径并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只能导致本条关键路径变成非关键路径，而无法缩短整个工期，因为其他关键路径没有变化。
            任何一条关键路径上的关键活动变长了，都会使这条关键路径变成更长的关键路径，并且导致其他关键路径变成非关键路径（如果关键路径不唯一），因此整个工期延长。
            而某些关键活动缩短则不一定缩短整个工期。  
                     
        最短路径
            从某源点到其余各项顶点的最短路径
            狄杰斯特拉算法 Dijkstra路径长度递增法
            
            开始点  终点   最短路径    路径长度
            v0      v1      无        
                    v2    v0,v2        10
                    v3    v0,v4,v3     50
                    v4    v0,v4        30
                    v5    v0,v4,v3,v5  60
                    
        
        每一对顶点间的最短路径
            1，狄杰斯特拉算法 Dijkstra
                以每一个顶点为源点，重复指向Dijkstra算法n次
                迪杰特拉斯算法求解了一个起始节点到所有其他节点的最短路径，时间复杂度为O(n**2) 
                即使人们可能只想知道从起始节点到某个特定的节点的最短路径，时间复杂度同样为O(n**2)
            2，弗洛伊德 Floyd算法
                求Vi到Vj的最短路径,如果vi 到vj有弧，则存在一条长度为arcs[i][j]的路径，该路径不一定是最短路径，尚需进行n次试探
                Floyd-Warshall算法的时间复杂度为O(N**3)，空间复杂度为O(N**2)
        
            
             
## 十一 查找
    11.1 静态查找表
        查找基于数据逻辑结构(D,R)定义的一种十分常见的运算，即确定某数据元素是否在数据元素集的问题
        11.1.1 术语:
            关键字，D={a1,a2...an}的每个数据元素ai有唯一标志的分量，记为ai.key
            一般描述形式 Search(T,key)，即查找key是否在T中
        Search函数
            Search(T,key)返回值或函数值定义为以下三种之一
            1，Search(T,key) = {True, False}  # true表示key在T中，反之亦然
            2，Search(T,key) = {i, 0}  # i表示key在T中 ki=key，0表示key不在T中
            3，Search(T,key) = {p, Null}  # p表示key在T中 ki=key，Null表示key在T中
        静态查找表算法思想
            依次与每个关键字逐个比较，如果给定值相等，查找成功，否则失败
        平均查找长度(Average Search Length)
            成功平均查找长度  ASL = 𝞢(i=1,n)PiCi (pici分别为查找的第i个关键字概率和比较次数，n为表长)
            失败平均查找长度  ASL= 𝞢(i=1,m)QiCi(qici分别为第i种失败概率和关键字比较次数，m为失败情况)
        算法改进:哨兵技术
        有序表查找
            折半查找法，大于给定值，在表左半边查找，小于给定值，在表右部查找
            也称二分搜索（英语：binary search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法
            折半查找法的优点是比较次数少，查找速度快，平均性能好；
            其缺点是要求待查表为有序表，且插入删除困难。
            因此，折半查找方法适用于不经常变动而查找频繁的有序列表
            算法步骤:
            1,计算中间位置；2，用待查关键字比较，相同则返回，小于则查左部，大于则查右部
            3，对确定的区域再按折半公式，重复上述步骤
            存储结构：一般使用一维数组
            时间复杂度log(n)
            画出二叉树，然后把叶子补足。叶子的高度就是查找失败的次数。然后求和除以叶子数目就是失败的平均查找长度
            成功查找长度:
            折半查找判定数中，某结点所在的层数就是即将要比较的次数，
            整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的长度
            n为数据元素个数，((n+1)/n ) *log2(n+1)-1 (其中对数中的2为底数：即log以2为底（n+1)的对数）
                注 : 当n很大时，可近似为 log2(n+1)-1
                n = 11时， ASL_succ = (12/11)log2(12)-1 = 3
            
            ** 失败:
            * 失败最少比对次数的问题？？
            折半查找判定数中，查找不成功的次数即为查找相应外结点与内结点的比较次数。
            整个判定树代表的有序表的平均查找长度。
            查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。
            外结点，所有外界点都是查找不成功的情况,如果有序表的长度为n,则外结点一定有n+1个,即树里叶子的虚拟结点和叶子的兄弟结点
            ASL=(4*5+5*7)/12=55/12;   4～5次
             
        计算中间位置的其他方法
            斐波那契序列法(n=F_u -1) F_u = {0,1, f_u+1 + F_u+2 } （u>1）
            线性插值法
        11.1.2 索引顺序表查找
            分块查找法:
            利用关键字序列分段有序性，建立分段索引表，借助分段索引表，实现快速查找    
            思想: 1，在分段索引表中，顺序或合并的查找给定值所在； 2，在1确定的块中，顺序查找给定值
            复杂度:
            假设索引表的平均查找长度ASL_b, 查找表上平均查找长度ASL_w 则 ASL = ASL_b+ASL_w
            顺序查找: ASL = n**(1/2) + 1
            折半查找: ASL = LOG_2(n/s + 1) + S/2
                
    11.2 动态查找表
        1,二叉排序树
            定义:
            一棵非空树T满足
            1,T的左子树非空，则左子树索引结点值小于T的根值
            2,T的右子树非空，则右子树索引结点值大于T的根值
            那么T的左右子树均为二叉排序树
            查找方案，基于T=(D,R),创建对应的二叉排序树
            查找算法: Locate(T,k)
            1,如果排序树T为空，返回 false
            2,如果排序树T根值>待查找值k，则在T的左子树上递归查找，否则T的右子树递归查找
            插入算法: Insert(&T,k)
            根据关键字k，在排序树T上查找，并在失败处插入之
            创建算法:Create(&T,definit)
            根据DS=(D,R)的关键字序列，对每个关键字k，逐个在排序树T查找，并在失败处插入之
            对于有n个关键字的n! 种排列，对应的二叉排序树高度区间为 log_2 n ~ n
            二叉排序树，删除算法，假设P指向被删除结点
            示例:
                尝试构造二叉排序树(45,12,78,37,24,1,99,61,90,53)，并计算平均查找长度ASL
                ASL_succ = (1*1 + 2*2 + 3*4 + 4*3)/10 = 2.9
                ASL_fail = (3*5 + 4*6)/10 = 3.6
        2,平衡二叉树 Balancwed Binary Tree
            满足以下性质的一棵非空二叉树T
            1，T的左右子树的深度之差的绝对值不超过1
            2，T的左右子树均为平衡二叉树
            二叉树T的结点平衡因子BF(Balance Factor)为左子树的深度减去右子树的深度
            当 T的|BF| <= 1时，T是平衡二叉树
            算法:
                创建算法 Create(&T,definit)
                根据DS=(D,R)的关键字序列，每一个关键字k，逐个在平衡排序树T上查找，在失败处插入，如果T失去平衡，对最小不平衡子树进行平衡化处理
                最小不平衡子树:是从插入结点k到二叉平衡树T的根 路径上，距离结点k最近的，平衡因子绝对值>1的结点为根的子树
                如下 (45,12,78,37,24,1,99,61,90,53)  12-37-24就是最小不平衡子树
                        45
                       /  \
                     12    53
                       \
                       37
                      /
                     24
                平衡化方法
                当平衡排序树T上插入失去平衡时，处理如下
                1。单向右旋，插入点是最小不平衡子树的左子树之左子树
                2。单向左旋，插入点是最小不平衡子树的右子树之右子树 
                3。左旋右旋，插入点是最小不平衡子树的左子树之右子树
                4。右旋左旋，插入点是最小不平衡子树的右子树之左子树
            示例:
                尝试构造平衡二叉树(13,24,37,53,90)，并计算平均查找长度ASL
                ASL_succ = (1*1 + 2*2 + 3*2)/5 = 2.2
                ASL_fail = (2*2 + 3*4)/6 = 2.7
        3,B- 和 B+树
            一棵m阶B-树，满足
            1，树中每个结点至多m颗子树
            2，如果根结点不是叶子结点，至少两颗子树
            3，除了根之外的所有非终端结点至少有 m/2 个子树
            4，所有非终端结点中包含下列数据项目 (n,A0,k1,A1,k2,A3,...kn,An) 
                m/2 <n<m-1为关键字个数,ki为关键字,Ai为指向子树根结点的指针
            5，所有叶子结点在同一层，不带信息
        特征:B- 树是一种平衡多路查找树，除了根结点之外，每个非终端结点含有m/2 ~m颗子树，
        叶子结点是空指针指向的,并不存在实际结点，含义是查找失败的结点,
        四阶B-树：
                    1_38_ _
           1 _ 18 _             2 _ 43 _ 78 _
        1 _ 11 _  1 _ 27 _    1 _ 39 _   2 _ 47 _ 53 _ 64 _  
          F    F    F    F      F    F     F    F    F    F
        B- 查找算法
            根结点开始，没找到进入子树查找，仍然没找到进入叶子结点(空子树)表示查找失败
            时间复杂度，最坏情况 T(N,m) = O(log(m*N)) = O(logN) m为常量时 
        B- m阶插入算法
            从根结点开始，查找待插入key值，直到叶子结点，失败    
        B- m阶删除算法
            先查找待删除的关键字结点，然后在该结点删除关键字k
            终端结点分4种情况处理
            1,终端结点关键字个数 >= m/2
                待删除关键字k和右邻指针直接删除
            2,终端结点关键字个数= m/2-1,右兄弟结点关键字个数 > m/2 -1
                删除k，将右兄弟结点父指针左邻关键字x插入到k之前所在结点，将右兄弟结点中最小关键字m，上移到
                父结点的原关键字x所在位置
            3,终端结点关键字个数= m/2-1,左兄弟结点关键字个数 > m/2 -1
                删除k，将左兄弟结点父指针右邻关键字x插入到k之前所在结点，将左兄弟结点中最小关键字m，上移到
                父结点的原关键字x所在位置
            4,终端结点关键字个数= m/2-1,左右兄弟结点关键字个数 > m/2 -1
                删除k后，加上父结点指向右兄弟结点左邻关键字x，一起合并到右兄弟
                合并后如果父结点关键字个数小于 m/2 -1， 则父结点依次做上述相同结点合并，直到结点关键字个数不小于m/2 -1，
                或直到根结点为止
        B+ 树, 是B-树的变形
            差别在于1，n颗子树中含有n个关键字
            2，所有叶子结点中包含全部关键字信息，及指向含有这些关键字记录的指针，叶子结点依关键字大小顺序链接
            3，所有非终端结点中仅含有其子树中最大或最小关键字
        B+树查找，与B-树查找类似
        键树 ，是一棵度 >=2的树，树中每个结点中仅含有一个关键字组成的符号，键树又称数字查找树
        键树存储结构1，二叉链表；2，多重链表 此时键树又称Trie树，树的度较高时适合
        键树查找算法，时间效率
            关键字每位取每个字符等概率时 (1+)/2
            每个关键字位数相同是等概率时 h(1+)/2                
    11.3 哈希表
        哈希表查找(散列查找)，根据关键字K计算其对应的数据元素的存储地址
        算法复杂度 O(1) 常量时间
        核心:
        1,设计Hash函数
            Hash构造方法，对于关键字集合每个关键字key，经过哈希函数H(key)映射到哈希地址集合中的任何一个地址概率相同
            则称哈希H(key)为 Uniform 均匀哈希函数，作用：避免冲突情况即同义词的过度集中，预期哈希查找的平均效率能够达到最佳。
            1，每类同义字个数相同或大致相等  2，均匀性在于冲突较少
            构造方法:
                1,直接定址法， H(key) = a*key+b (a!=0)
                2,数字分析法
                假定预先知道可能出现的关键字子集，分析这些关键字的每一位，选择其中若干，随机位构成其哈希地址
                随机颗计算，颗结合叠加法
                选数据中随机性比较高的 其中几位作为hash地址
                k1 8 1 9 1 0 7 8 9 8 0
                k2 8 1 0 2 4 3 6 7 5 8
                k3 8 1 1 4 7 2 3 8 9 7
                如上 第4，5位随机性比较高，可以选择 H(k3) = 47
                3，平方取中法
                    取关键字平方后的中间若干位为哈希地址 的方法
                    key a1a2...a4
                        a1a2...a4 x
                     ----------------
                     a1a1a2a2..a4a4
                           ^^ 
                4，折叠法
                    将关键字分割称位数相同的若干段，各段叠加求和为哈希地址 的方法
                5，余数法
                    取关键字被不大于哈希表长m的某个树p出后的余数为哈希地址 的方法
                    H(key) = key MOD p (p<=m)  p取为质数或不含小于20质因子的合数
                    序列:[27,17,9,19,16,43,53,8,63]
                         3   1 1  3  0  3  5  0 7
                    H(key) = key MOD 8 + 链地址冲突法
                     16 17 9 27 19 43 53 8  63
                     0  1  2 3  4  5  6  7  8  9  10  11
                    所以如果要查找到 43，原余数位为3号，但是实际需要匹配27，19，43 共3次
            
        2,解决Hash冲突
        函数理论取值范围远远大于实际取值范围
            1，开放地址法  Hi(key) = (H(key)+di) MOD m  #H(key)为哈希函数 m为表长，di为增量 
            增量di的取法：1，线性探测再散列 1 ， 2 ， 3 ， …… 
                        2，二叉探测 1^2 ，－ 1^2 ， 2^2 ，－ 2^2 ， k^2， -k^2……
                        3，伪随机数探测  1，2，4，6...
               设有哈希函数 H ( key ) = key mod 7 ，哈希表的地址空间为 0 ～ 6 ，对关键字序列（ 32 ， 13 ， 49 ， 55 ， 22 ， 38 ， 21 ）按线性探测再散列和二次探测再散列的方法分别构造哈希表
               线性探测再散列：
                    32 ％ 7 = 4 ； 13 ％ 7 = 6 ； 49 ％ 7 = 0 ；
                    55 ％ 7 = 6 发生冲突，下一个存储地址（ 6 ＋ 1 ）％ 7 ＝ 0 ，仍然发生冲突，再下一个存储地址：（ 6 ＋ 2 ）％ 7 ＝ 1 未发生冲突，可以存入         
            2，再哈希法
                Hi(key) = RHi(key) (i=1,2,3...k)
                RHi(key)为不同哈希函数，不容易出现聚集，但是增加了计算时间
            3，链地址法
                将关键字同义词存储在各自单链表中
            4，公共溢出区法
                当增加关键字到哈希表遇到冲突时，将所有同义词统一存储到 公共溢出区
        3，哈希查找及分析
            查找算法
            1，给定值key对应计算的哈希地址H(key)中查找
            2，如果1查不到，根据处理冲突方法确定'下一个地址'处查找
            3，重复2直到成功，或遇到'结束标志'为止
            说明：
            '下一个地址' 和'结束标志'由处理冲突方法决定的
            查找算法中既使用算术运算，也有比较运算
            插入算法在查找失败处增加新关键字
            创建算法在循环调用插入运算实现
            删除运算的实现是在查找成功处删除某个数据元素。对于某些处理冲突的方法，删除实际上是填入'删除标志'
        问题:
            哈希表装填因子:哈希表中填入的关键字个数于哈希表长之比
            线性搜索法 
                ASL_succ = 1/2(1+1/(1-alpha))
                ASL_fail = 1/2(1+1/(1-alpha)**2)
            二次搜索法
                ASL_succ = -1/alpha ln(1-alpha)
                ASL_fail = -1/(1-alpha)
            链接地址法
                ASL_succ = 1 + alpha/2
                ASL_fail = alpha + e**(-alpha) 
            删除运算的实现是在查找成功处删除，某些时候，删除只是填入'删除标志'，并且查找算法需要调整
            特殊情况下，哈希函数 存在 无处理冲突   
            ASL成功=成功查找次数/数据元素长度 
            ASL失败=失败查找次数/数据元素长度  
## 十二 内部排序，内存数据排序
    外部排序，磁盘排序
    排序是基于数据逻辑结构(D,R)定义的一种十分常见的运算。数学上，'排序'是指依据D的每个元素之关键字，按照递增-递减顺序将数据元素排列的过程
    次关键字，标识多个(>1)数据元素的分量，称为次关键字
    排序算法稳定: 次关键字排序后顺序不变
    不稳定:次关键字排序后顺序改变
    一般描述形式 sort(T,fkey,up_dn)
    根据给定关键字分量，按照up_dn的不减序，不增序，对T排序
    12.1    插入排序
        循环静态链表
        1,直接插入排序，在递增(递减)有序表t上，插入一个元素x，使其仍然保持有序
        步骤:1，确定插入位置；2，移动元素；3，填入新元素
        49，38，65，97，76，13，27，49
        比较次数
        Tb(n)=n-1
        Tw(n)=∑(i=2,n)i
        Ta(n)=(T_b + T_w)/2 = (n**2) /4
        移动次数:
        T_b()=0   # 最好情况
        T_w()=∑(i=2,n)(i+1)  # 最差情况为反序 算法时间复杂度 T(n)=O(n**2)
        
        2,折半插入排序
        定位除了上述顺序定位法，还可以利用有序子表的特点，进行折半定位法
        L:(a1,a2...ai+1)
        当定位结束(即L>H)时，aL ~ ai_1向后移动
        算法分析
            比较次数，T_b(n) = n-1, T_w(n) = ∑(i=1,n01) logi = nlogn
            算法时间复杂度T(n)=O(n**2)
        
        3,2路插入排序
        将关键字排序在辅助空间中
        2-路插入排序相比于折半插入排序，只是减少了移动记录的次数，没有根本上避免，所以其时间复杂度仍为O(n2)
        算法思想
            1,取出表 L=(a1,a2...an)的第1个元素a1存入辅助空间D[1]
            2,取出表L的下一个元素a1，如果a1<D[1]，则插入到D[1]左边的有序子表，否则插入到D[1]右边有序子表
            3，重复2，直到表L最后一个元素an插入后为止
        算法时间复杂度
            比较次数不变 H， 移动次数 T_b()=0， T_w()=不变，T_a(n)_=(n**2)/8
            T(n)=O(n**2)
        4,表插入排序(静态链表，ai内部结构增加一个静态指针)
            算法思想，从表L=(a1,a2...an)的第2个元素a2开始到an为止，逐个插入本元素左边有序子表，使其仍然有序，从小到大方向定位(即第一次遇到大于ai元素之前插入)
            插入时仅修改指针
            哨兵技术
            算法时间复杂度 T(n)=O(n**2)
    12.2    交换排序
            通过两个元素之间的交换，逐步使得元素移动到表L的正确位置
            1，冒泡排序
            1,1,比较相邻的元素。如果第一个比第二个大，就交换他们两个。
            1.2,对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
            1.3,针对所有的元素重复以上的步骤，除了最后一个。
            1.4,持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
            冒泡排序最好的时间复杂度为O(n),总的平均时间复杂度为 O(n**2)
            此排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；
            如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法
            2，快速排序
                1，依据表L=(a1,a2...an)的第一个元素a1将取L '划分'为左右2个逻辑子表，使得a1小于左子表所有元素，且大于右子表所有元素
                2，左右子表分别递归处理
                算法核心思想是 '划分'处理
                划分方法:low 和high初始值分布指向L最左和最右的单元
                    1，当low<high时，重复做如下处理，high为最右的值，low为最左的值
                    1.1, 向左移动high，将首次遇到的小于 L(low) 之 L(high) 与L(low)互换
                    1.2, 向右移动low，将首次遇到的大于>= L(high)之L(low) 与L(high)互换
                    1.3, 重复以上操作，当序列下标 low>high时，low所在位置为当前元素的正确位置，同时'划分结束',low的左侧为序列1,low的右侧为序列2 不包括low
                算法时间复杂度由 "二叉树的每层划分需要的比较次数和交换次数" X "二叉树的层数高度" 确定，所以二叉树层数最低时(nlogn)为最小时间复杂度    
                
                算法分析:设排序元素个数为n，统计比较次数，则
                T_w(n)<=n**2  (在有序情况下),二叉树层数达到最大n
                T_b(n)<=nlogn (每次划分均为左右子表相等情况)
                T_a(n) <=cnlogn
                假设n个元素平均比较次数为T_a(n)划分后左子表元素个数为i，并且i取(0~n-1)是等概率的，则
                T_a(n) = dn + 1/n ∑(i=0,n-1)(T_a(i)+T_a(n-i-1)) <= cnlogn
                    T
                 i     n-i-1
                例子1:
                27  38  113  19  76  97  18  49          #第一步比较 high的值 49 大于 low的值27，不发生交换
                low                         high
                27  38  113  19  76  97  18  49          #第二步移动high位置到 向前一步，此时high的值18小于27，交换
                low                     high  
                18  38  113  19  76  97  27  49          #第三步，此时high为27，移动low向后，此时low的值38大于high的值27, 从左方找到比此时high更大的第一个值38,交换
                    low                 high 
                18  27  113  19  76  97  38  49          #第四步，此时low为27，high移动向前，从low的右方找到比low值27更小的值，97和76都比27大，不交换
                    low            high
                18  19  113  27  76  97  38  49          #第五步，继续移动high向前，值为19，此时low的值27，交换
                    low     high              
                18  19  113  27  76  97  38  49          #第六步，此时high为27，low向右移动，找到比27大的数，113比27大，交换
                        low high
                18  19  27  113  76  97  38  49          #第七步，此时low的值27，high为113，high继续向左移动，找到比low更小的值
                        low high
                18  19  27  113  76  97  38  49          #第八步，此时high移动一步到 19，low的值27，此时 low的序列号> high，
                   high low
                划分结束，得到两个单元子表即low的左右两侧的值组成的单元(18,19),(113  76  97  38  49)
                
    12.3    选择排序
             选择表L最大/小元素，与最后位置上元素交换
             1,简单选择排序
                1，对于表L=(a1,a2...an)
                2,对于除最后一个元素外的剩余部分构成子表重复(1)，直到剩余部分构成子表表长 = 1
                算法分析: 比较次数 T_w(n)=T_b(n)=(n-1)+(n-2)...(1)=O(n**2)=T_a(n)
             2,堆排序
                表L=(a1,a2...an)，可以视同是完全二叉树的顺序存储结构，其一一对于关系有二叉树性质5决定
                27  38  13  49  76  97  65  49
                定义: 堆是满足下列条件的完全二叉树，也称大顶堆，大根堆，适用于增序排序
                1，T的根值不小于其左子树和右子树的根值；2，左子树和右子树均满足1
                空完全二叉树为大顶堆，根值为 -∞
                左右子数为对，仅仅是T的根不满足堆的条件之情况，将T转换为堆的过程称为调整堆
                调整堆算法思想:
                    1，将树根与其左右子树根值最大者交换
                    2，堆交换后堆左或右子树重复1，直到左或右子树为堆
                创建堆算法
                从最大序号开始逐步到根，对于每个子树采用调整堆算法使其成堆
                
                堆排序算法思想:
                    1,创建堆，从最后一个非叶子结点开始逐步到树根，对每个子树进行调整堆
                    2,重复n-1次如下处理:将堆堆根与最后一个叶子交换，除最后一个叶子之外堆剩余部分再调整堆
                算法分析:T_w(n)=T_a(n)
                实际上，1，创建堆所需比较次数 <=4n
                       2, 交换调整堆所需比较次数 <=logn!
                38 97 65 76 49 13 27 49
                创建堆
                        97
                    76      65
                  49  49  13  27
                38
                2，调整，根和最后一叶子交换
                38 65 76 49 13 27 49 97
                38 76 65 49 49 13 27 97  #把1-7数据元素组成调整为堆
                76 49 65 38 49 13 27 97  #调整为堆
                        76 
                    49     65
                  38  49  13  27
                (97)
                3，交换完全二叉树根的值 和 叶子结点,调整为堆    # 重复1～3步骤，一共n-1次完成排序
                65 49 27 38 13 76 97   # 二叉树的先序序列
                        65
                    49     27
                  38  49  13  (76) 
                (97)
                4，交换堆顶和末叶子
                13 49 27 38 49 65 76 97
                        13
                    49      27
                  38  49  (65) (76)
                 (97)
                剩余5个数再次生成大顶堆
                        49
                    49      27
                  38  13 (65) (76)
                (97)
                交换堆顶和最后一个叶子,剩余 4个数再次生成大堆顶
                13 49 27 38 49 65 76 97
                        49
                   38        27
                13   (49)   (65) (76)
              (97)
                        13
                   38         27
              (49)   (49) (65)  (76) 
             (97)
                        38
                    13     27
                        27
                    13     (38)
              以下树堆先序序列就是数列堆 增序序列
                        13
                    27      (38)
                (49)  (49) (65) (76)
               (97)
                    
                      
    12.4    归并排序
        （MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)
        速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列，移动次数多于快速排序
        两个有序表合并 merge 成为一个有序表
        算法思想: L=(a1,a2...an)的每个元素，看成一个有序子表
        1，从左到右，将相邻两个有序子表合并
        2，重复1，直到所有子表合并成一个有序子表为止
        算法分析
        T_w(n)=O(nlogn), 最坏情况O(nlogn)
        步骤:
        设有数列{6，202，100，301，38，8，1}
        初始状态：6,202,100,301,38,8,1
        第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；
        第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；
        第三次归并后：{1,6,8,38,100,202,301},比较次数：4；
        总的比较次数为：3+4+4=11；
        逆序数为14；
        
        归并操作的工作原理如下：
        第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
        第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置
        第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
        重复步骤3直到某一指针超出序列尾
        将另一序列剩下的所有元素直接复制到合并序列尾
        
    12.5    基数排序(桶排序)
        判定键值是否为堆，不依赖于关键字的比较运算，对当逻辑关系排序的方法
        {100,60,70,50,32,65}
        100 为最主位关键字
        65 为最次位关键字
            把这个序列看成数组型的二叉树，如果根结点是i，左子树是2*i，右子树是2*i+1。
            堆分为最大/小堆 
            最大堆中所有父节点都比左子树、右子树大，
            最小堆中所有父节点都比左子树、右子树小，
        多关键字排序,稳定性的排序
        最高位优先排序(MSD- Most Significant Digit first)
        最低位优先排序LSD（Least significant digital)
        将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
        排序算法采用 链表结构实现对数据序列排序,进行插入或删除操作,只需修改指针,可以避免移动大量记录
        
        基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，
        它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序
        
        依据第一关键字K**0排序，之后对于具有相同K**0值的子序列，再依据第二关键字K**1分别排序，
        类推直到对应子序列分别依据d关键字k**d排序为止，将所有子序列链接在一起构成整个有序序列
        
        排序算法必须具有稳定性
        其原理是将关键字每一位K**m视同单关键字，这样就构成多关键字(K0K1K2...Kn-1),并采用LSD方法排序
        算法思想:
        按照每位K**m(m=n-1~0)值,将关键字依次进行'入桶'操作，以后依次进行'出桶' 操作
        假设表中数据元素为n个，即问题规模为n，关键字的基数r，每个关键字有d位
        基数排序一共需要进行d趟，每趟每个关键字需要2次移动(入桶和出桶)，每趟合计移动2n次
        基数排序共计移动2nd次，即:T(n,d)=O(d n),这是时间复杂度
        需要额外r n个存储空间，S(n,r) = O(r n)
        
        时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法
        
        空间复杂度就是在分配元素时，使用的桶空间；所以空间复杂度为：O（10 × length）= O （length) 
        主要步骤:
            开连续的数组空间，存储待排序的排序关键字，这个空间可以是数组
            1、把所有元素都分配到相应的桶中

            2、把所有桶中的元素都集合起来放回到数组中

            3、依次循环上面两步，循环次数为最大元素最高位数
        数据结构设计：链表可以采用很多种方式实现，通常的方法是动态申请内存建立结点，但是针对这个算法，桶里面的链表结果每次扫描后都不同，就有很多链表的分离和重建
        例1:500w高考考生排序
        分析：对500W数据排序，如果基于比较的先进排序，平均比较次数为O(5000000*log5000000)≈1.112亿。但是我们发现，这些数据都有特殊的条件： 100=<score<=900。那么我们就可以考虑桶排序这样一个“投机取巧”的办法、让其在毫秒级别就完成500万排序。
        方法：创建801(900-100)个桶。将每个考生的分数丢进f(score)=score-100的桶中。这个过程从头到尾遍历一遍数据只需要500W次。然后根据桶号大小依次将桶中数值输出，即可以得到一个有序的序列。而且可以很容易的得到100分有***人，501分有***人。
        实际上，桶排序对数据的条件有特殊要求，如果上面的分数不是从100-900，而是从0-2亿，那么分配2亿个桶显然是不可能的。所以桶排序有其局限性，适合元素值集合并不大的情况
        例2:有一个10G整数的文件，乱序，需要找出中位数
        分析：既然要找中位数，很简单就是排序的想法。那么基于字节的桶排序是一个可行的方法
        思想：将整型的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的字典序    
    12.6    希尔排序
        1，算法思想
            1，将表L=(a1,a2...an)划分称若干逻辑子表，分别对其进行直接插入排序（仍然是一个表）
            2，依据逻辑子表个数逐步递减原则，重复1，直到表L构成一个逻辑子表
        
        2，算法时间复杂度与增量序列密切相关，大约为 O(n**1.5) 或O(n**1.3)
        先取一个正整数d1<n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止
        希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止
        
    12.7    方法比较        
                         比较次数     最好/最坏情况时间复杂度        空间复杂度         稳定性
         方法              T_a()           T_w()           S()
        直接插入排序  Ta(n)=(n**2) /4       (n**2)          O(1)            Y 
     插 折半插入排序        nlogn         O(n**2)           o(N)            Y
     入 2-路插入排序      O(n**2)        (n**2)/8           o(N)             Y
        表插入排序           /            O(n**2)           O(1)            No
        希尔排序        O(n**1.5)           /               O(1)            No
        
     交  冒泡排序        O(n)#最佳时        O(n**2)/O(n**2)         O(1)              YES
     换  快速排序          cnlogn          n**2            O(log2n)~O(n)     NO
     
     选  简单选择排序      O(n**2)         O(n**2)         O(1)                Y
     择  树形选择排序      O(n*log2n)      O(n**2)        O(n)               不确定   
         (二叉树排序)
         堆排序           n*log_2(n)      log_2(n)       O(1)                 No
         归并排序         O(n)            O(nlogn)        O(n)                 No
         基数排序        O(nlog(r)m)      O( k*n )        O(n)                 Y
            * 其中k为常数，n为元素个数
         基于比较运算的排序算法，时间复杂度下界为O(nlogn)
         
## 十三 串
    字符串使用单独一种存储结构来存储，称为串存储结构。
    字符串的存储结构
    分类:
        空串         包含0个字符的串
        空格串       只包含空格字符的串
        子串和主串   如果a中可以找到连续字串在b中能找到，就称a是b的子串，如:a='abc'，b='abcd'
    位置
        子串在主串的位置， 串在主串中的位置，指的是子串首个字符在主串中的位置。
    存储实现
        顺序存储    静态数组，在c中如，char a[13] = "www.google.cn"
        堆分配存储  用动态数组存储字符串
            malloc 函数 手工申请，使用完成后free释放
        块链存储    用链表存储字符串 
    算法(串模式匹配算法)
        1，BF算法，普通模式匹配算法，暴力匹配算法
        一种用来判断两个串之间 是否具有 '子串-主串'关系的算法
        基本思想：将用户指定的两个串A 和串B，使用串的定长顺序存储结构存储起来，然后使用循环实现两个串的模式匹配过程
        复杂度:
        最理想的时间复杂度 O(n)，n 表示串 A 的长度，即第一次匹配就成功
        最坏情况的时间复杂度为 O(n*m),两个串每次匹配，都必须匹配至串 A 的最末尾才能判断匹配失败，因此运行了 n*m 次
        特点:
            没有任何技巧，效率较低
            
        2，KMP算法
         Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，
         这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法
         2.1,基于最大长度表匹配
         2.2,基于next数组匹配
         时间复杂度
         如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)
        3，BM算法
         字符串匹配算法：Boyer-Moore算法，简称BM算法
         该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高
         规则:
         3.1 坏字符规则
         当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，
         移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1   
         3.2 好后缀规则
         当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1
         时间复杂度，O(n) n为模式串长度
       4，Sunday算法  
         Sunday算法由Daniel M.Sunday在1990年提出
         规则:
            1，Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。
            2，如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1
            3，否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1
         例:
         现有文本串 "subneting setwork algorithm" 找到模式串"setwork"
         step_1，将文本串和模式串头对齐
         subneting setwork algorithm
         setwork
         ^
         step_2, 发现模式串第二个字符不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一字符，即subneting的 n
         因为模式串中没有n，所以模式串跳过这些，向右移动位数 = 模式串长度+1 = 7+1=8，从n之后的g开始匹配
         subneting setwork algorithm
                 setwork
                  ^
         step_3，第一个字符就不匹配,看参加匹配的文本串的下一位字符是r，他出现在模式串的-2位，于是把模式串向右移动2位
         使两个r对齐
         subneting setwork algorithm
                   setwork
                         ^
         step_4，匹配成功，这里只移动了两次就匹配成功，效率较高。
         
### 附 递归，迭代，循环，遍历
    
####    循环（loop）
    指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。
        while n < 10:
            print(n+1)
    迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。
    自动迭代的一种更优雅的方法是使用for循环。使用此方法，我们可以迭代可以返回迭代器的任何对象，例如列表，字符串，文件等
        1,关键字 yield
            def iter_yie(n):
                while n:
                    n -= 1
                    yield n
            ite_100 = iter_yie(100)
            >>> next(ite_100)
                99
                
        2, 循环设计
        ite = iter(range(10)
        next(ite)
        for i in ite:
            print(i+1)
        自定义迭代类型
        class PowIter:
        """Class to implement an iterator of powers of iter"""

            def __init__(self, max = 0):
                self.max = max

            def __iter__(self):
                self.n = 0
                return self

            def __next__(self):
                if self.n <= self.max:
                    result = 2 ** self.n
                    self.n += 1
                    return result
                else:
                    raise StopIteration
        a = PowIter(4)
        >>> i = iter(a)
        >>> next(i)
            1
####    遍历（traversal）
    可迭代对象都可以被遍历
    指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。
    1, 简单列表遍历
    for i in list(range(100)):
        print(i)
    
    ```python
        class Node:
        def __init__(self,data):
            self.left = None
            self.right = None
            self.data = data

        def inOrder(root):
            if root:
                inOrder(root.left)
                print (root.data)
                inOrder(root.right)

        def preOrder(root):
            if root:
                print (root.data)
                preOrder(root.left)
                preOrder(root.right)

        def postOrder(root):
            if root:
                postOrder(root.left)
                postOrder(root.right)
                print (root.data)

    #making the tree 
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    print inOrder(root)
    #4 2 5 1 3
    print preOrder(root)
    #1 2 4 5 3
    print postOrder(root)
    #4 5 2 3 1
        
####    递归（recursion）
    指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列
    #  递归， 默认最多1000层
    @functools.lru_cache(maxsize=None)   # 计算性能
    def fb(n):  # 第几个fbnc数
	    if n <= 2:
		    return 1
	    else:
		    return fb(n-1) + fb(n-2)
    实例见code        
         