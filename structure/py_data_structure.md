# 概述
    主要作用，分析待处理 **对象的特征**，各处理对象之间的关系
    数据结构是一门讨论"描述现实世界实体的数学模型(非数值计算)"及其上的操作在计算机中如何表示和实现
    
    1，抽象一个适当的数学模型
    2，设计一个解此数学模型的算法
    3，调试直到解答完毕
    
## 一，基本概念和术语
    1，数据data
        所有能输入计算机并被程序处理的符合的总称
        包括不限于整数，实数，字符，声音，图像，图形
    2，数据元素data element
        数据的基本单位，元素，记录，结点，顶点
        在计算机程序中通常作为一个整体考虑和处理
        一个数据元素可以由一个或多个数据组成
        
    3，数据项data item
        数据不可分割的最小单位，如姓名，年龄
        
    4，数据对象data object
        由性质相同的数据元素组成的集合
        数据对象是数据的一个子集
        如4个整数组成的数据对象，有限集
            lis1 = {1,2,3,4}
        又如由正整数组成的数据对象无穷集
            lis2 = {1,2,3...}
    5, 数据结构data structure
        相互之间存在一种或多种特定关系的数据元素的集合，这个关系称为结构
        四类基本关系:
            集合
            线性结构
                数据元素一对一的相互关系
            树形结构
                数据元素一对多的相互关系
            图状结构
                数据元素多对多的相互关系
    6, 数据的逻辑结构
        各数据元素之间的逻辑关系，逻辑分类
        数据结构，分为线性，非线性
            
    7, 存储结构
        数据结构在计算机存储器中的映像(mapping)
        存储结构也称 存储表示，物理结构，物理表示
    
    8, 数据类型
        原子类型(int,char,float等)
        结构类型(数组，结构，联合体)
    9, 抽象数据类型(Abstract data Type)
        与计算机的实现无关的数据类型
        形式定义
        ADT抽象数据类型名
        {1,数据对象
        2，数据关系，一个或多个关系
        3,一组基本操作/运算}
        
## 二，如何构建一个数据结构？
    1，分析问题的 具体操作对象
    2。找出对象间的关系，并用数学语言描述
    
### 算法加数据结构 = 程序设计
    算法是处理问题的策略，数据结构是给出问题的数学模型
    程序设计是编织出用计算机处理问题的指令


## 三，基本数据结构
    线性结构
        线性表，栈，队列，双队列，数组，字符串
        例如:
            图书特征索引，
            本例中的
            数据: 书目信息
            结构: 线性结构--顺序关系
            操作对象: 图书的特征，编号，书名，作者，出版日期
            对象间关系: 按某一索引项的线性关系排序，如编号
            
    非线性结构
        树，二叉树，图，网，堆，散列表(Hash)
        堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆
            1，堆通常是一个可以被看成一颗树的数组对象，有性质如下:
                堆中某节点值总是不大于或不小于其父节点的值
                堆总是一颗完全二叉树
                将根节点最大的堆叫做最大堆或大根堆，根节点最小的叫最小堆，小根堆
            2，堆是在程序运行时申请内存，动态分配内存，对其访问和对一般内存访问没有区别
            3，堆是应用程序在运行时请求操作系统分配给自己内存，一般是申请/给予过程
            4，堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(后进先出)
        例如:
            二叉堆，斐波那契堆
            人机对弈棋盘
            数据: 棋盘格局
            结构: 层次关系--树结构
        例三:
            五叉路口交通管理
            数据: 交通线路
            结构: 网状结构 -- 图结构
            问题的转换和抽象
            可以同时通车的道路对应的顶点染 相同的颜色
            有线段相连的顶点染不同颜色，使用颜色数尽量少
            
            需要满足:
                顶点的颜色与交通灯的颜色相对应
       
### 定义
    数据结构可以是数值类也可以是非数值类的
### 递归定义
    递归定义是数理逻辑和计算机科学用到的一种定义方式，使用被定义对象的自身来为其下定义（简单说就是自我复制的定义）。
    递归定义(recursive definition)亦称归纳定义，一种实质定义，指用递归的方法给一个概念下的定义。
### 特性

### 运算
    
    数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。
    一般有以下几种常用运算
    检索
        在数据结构中查找满足一定条件多节点，一般是给定一个字段多值，找具有该字段值的节点
    插入
        在数据结构中增加新的节点
    删除
        把指定节点从数据结果中删除
    更新
        改变指定节点一个或多个值
    排序
        把节点按某种指定顺序重新排列，递增或递减
    
### 算法
    1,定义:
        求解一个特定问题的指令的有限序列
    2, 好算法的特征
        有穷性
            有跳出和终止
        确定性
            指令没有二义性
        可行性
            算法操作都是已经实现的基本运算执行有限次来实现
        输入
            有0各多个输入
        输出
            有至少一个输出
    
    3, 分类
    查找算法
        顺序，折半，分块，哈希，二叉排序树
    排序算法
        直接插入，堆排序，2-路归并，快速排序等
    
    算法设计要求
        正确性
            语法，对各种异常的处理
        可读性
            便于交流和维护
        健壮性
            异常输入的处理
        高效与低存储量
            
    算法分析
        主要任务
        目的  
        
    算法描述工具:
        1, 自然语言
        2，程序设计语言
        3，流程图
        4，伪码语言
        5，类C
    
    4, 算法时间复杂度
        算法或程序中基本操作或语句重复执行次数的总和
        n为求解的问题规模，基本操作或语句执行次数的总和称为语句频度f(n)
        时间复杂度记为: T(n)
        
        T(n) = O(f(n))  #执行时间为f(n)
        
        4.1 常见的时间复杂度
        O(n) 线性阶，线性数量级
        O(n**2) 平方阶，平方数量级
        
        O(1), O(log_2_n), O(n), O(n*log_2_n), O(n**3), O(2**n)
        O(1)<O(log_2_n)<O(n)<O(n*log_2_n)<O(n**3)<O(2**n)
    
    5, 算法空间复杂度
        执行算法所需的存储空间大小
        S(n) = O(f(n)), n为问题规模
        存储空间，寄存指令，常熟，变量，输入数据，对数据进行操作的工作单元。实现计算所需空间
        

## 四，存储结构和实现
    存储节点 ？
        存储结点就是数据结点的存储映像，按照存储结构类型不同，这个存储结点中除了本身的数据元素以外，也许还存放有数据元素的关系
    存储结构是 数据结构在计算机存储器中的映像(mapping)
    存储结构也称 存储表示，物理结构，物理表示
    选择存储结构
        4.1 顺序存储结构(向量，一维数组)
        线性表 L = ('A','B','C','D')
        4.1 非顺序存储结构(链接表)
        单链表，分配不一定连续的空间，存放数据的空间顺序可任意
        链接、索引、散列

## 五，应用
    基本应用
    
    综合应用

## 六. 线性表的定义和操作
    6.1, 逻辑结构定义
    由n>=0各数据元素(a1,a2...)构成的有限序列
    记为: L = (a1,a2...an)
    顺序实现或链式实现
    
    6.2,线性表的特征
        a_i-1在 ai的前面， a_i-1 是 ai的直接前驱， a_i 是 a_i-1的直接后继
        a1没有前驱(即首元素没有前驱)
        an没有后继(即尾元素没有后继)
        其他每一个元素都有一个前驱和后继
    6.3,顺序存储结构的寻址公式
        根据线性表首地址来计算其他元素的存储地址
        
    6.4,插入算法实现举例
        有n个元素，在 n/2处插入一个元素，n/2之后的所有元素都会后移
        实现方法
        1，用指针指向被操作的线性表，静态分配
        2，用引用参数表示被操作的线性表
        3，动态分配线性表空间，用引用参数表示被操作的线性表
     6.5, 插入，删除元素的次数分析
     6.6, 顺序存储结构
        优点
            随机存储结构，任何元素存储时间是一个常数，速度快
            结构简单
            不使用指针
        缺点
            插入和删除元素需要移动大量元素，消耗大量时间
            需要一个连续的存储空间
            插入元素可能发生溢出
            自由区的存储空间不能被其他数据共享
     
     6.7 静态链表存储结构 
         结构数组的第一个元素可看成是头结点，其指针域指向的是链表的第一个结点。
         这种存储方式仍需事先分配一个较大的空间，但是在线性表插入或者删除数据时就不需移动数据了，只要指针位置即可
         ** 与动态链表区别
            异：静态链表是数组实现的，是顺序存储结构，在物理地址上是连续的，而且需要预先分配大小。
            动态链表是用内存申请函数（malloc）动态申请内存的，所以每个节点的物理地址是不连续的，要通过指针来顺序访问。

            同：在插入或者删除数据时只需修改指针即可，不用移动元素
     6.8 类型:
            
            1，单链表
                head 头指针，head=Null，为空表，否则为非空
                data-next (next称为指针域/链域)
            设计单链表类型如先进先出，后进先出
            
            插入
                在单链表指定位置插入新元素
                输入: 头指针L，位置i，数据元素
                输出: 成功返回OK，否则Error
                
            2，循环链表 
                非空循环链表(带表头)
                    tail 尾指针指向表尾结点
                    tail - >next指向表头结点
                    tail - >next - >next指向首结点
                空循环链表(带表头) 只设尾指针的循环链表
                    tail -> next == tail
                两个循环列表首尾相连
                    列表1的tail指向列表2的首元素
                    列表2的tail->next 指向列表1的 head
                    
            双向链表
                数据域，指针域
                前驱  <-->a1<---> 后继
                非空表
                空表
                删除节点需要考虑更多，
            双向循环链表
                空表
                L -> next==L->prior==L
                非空表
            
            
## 七，栈和队列
    线性表 L = (a1,a2...an)
    可在任意第i个位置 **删除|插入** 新元素
    受限数据结构
    插入和删除受限制的线性表
        栈(stack)
        队列(queue)
        双队列(deque)
        
    7.1, 栈定义和操作
        栈: 限定在表尾做插入，删除操作的线性表
        也称 后进先出表，LIFO表，反转存储器，地窖，堆栈
        (a1,a2...an)  
        栈底 a1  表头，不允许插入，删除的一端
        栈顶 an  表尾，允许插入，删除的一端
        进栈
            或称为: 入栈，推入，压入，push
            插入元素,默认an+1(进栈)
        出栈
            或称为: 退栈，上托，弹出，pop
            删除元素，默认删除an(出栈)
        空栈
            不含元素的栈
        
        自由区
            栈中空的位置
        进出原则
           
            后进先出 Last In First Out
    
    
    7.2，栈的基本操作
        1， Initstack(s)  置为空栈
        2， Push(s,e)     元素e 进 栈s
            若s已满，发生**溢出**
            若不能解决溢出，重新分配空间失败，则插入失败
        3， Pop(s,e)   删除栈s的顶元素，并送入e
            若s为空栈，发生 **下溢** (underflow)
            为空栈时，表示某项任务已经完成
        4， Gettop(s,e) 栈s的顶元素拷贝到e
            若s为空栈，结束拷贝
        5， Empty(s)  判断s是否空栈
            s是空栈，返回true，否则返回false
            
    7.3, 栈的存储表示和操作实现
        顺序栈
            用顺序的空间表示的栈
            设计实现方案时，需要考虑的因素
            栈元素和顶指针合并定义一个记录(结构)
            空间分配方案
                静态分配 typedef struct
                    栈元素空间，顶指针，sqstack为结构类型，s为结构类型变量，都需要指定
                动态分配
                    指向栈元素空间，顶指针，栈元素空间大小，相当于maxleng
                    s为结构类型变量
        链式栈
            不带表头节点的单链表
                  
        如何分配存储空间
            动态分配或静态分配
            栈空间范围  s[0, maxleng-1]
            
        如何设置进栈和出栈的标志top
            如top指向栈顶元素或指向栈顶元素上一空单元，作为进栈出栈的依据
        分析满栈的条件，用于进栈操作，
            top顶指针指向顶元素所在位置，进一个元素 top+=1
            先进再加
            若 top == maxlength -1 插入元素发生溢出 overflow
            先加再进
            top == maxlength
            
        分析空栈的条件，用于出栈操作，取出top栈顶元素，再对top -= 1
            先出再减
            若 top == -1，删除元素发生 下溢
         
            先减再出
            top == 0
    
    7.4, 栈的应用举例
        栈常用于，保存暂时不用的数据或存储地址
        数值转换如，给定10进制 1300，转换为8进制
        计算中的数字保存到栈中
        
        实际使用时使用多个栈，如
        操作数栈
        算符栈
        
        一个栈的cpp实现，详细
            //main.cpp   
            int   a   =   0;   全局初始化区   
            char   *p1;   全局未初始化区   
            main()   {   
            int   b;   栈   
            char   s[]   =   "abc";   栈   
            char   *p2;   栈   
            char   *p3   =   "123456";   123456/0在常量区，p3在栈上。   
            static   int   c   =0；   全局（静态）初始化区   
            p1   =   (char   *)malloc(10);   
            p2   =   (char   *)malloc(20);   
            分配得来得10和20字节的区域就在堆区。   
            strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 
            优化成一个地方。   } 
        
    7.10 队列(queue)
        队列及其操作
        定义:
            队列 -- 只允许在表的一端删除元素，在另一端插入元素的线性表
            空队列  不含元素的队列
            队首   队列中只允许删除元素的一端  head front
            队尾   队列中只允许插入元素的一端  rear tail
            队首元素  处于队首的元素
            队尾元素  处于队尾的元素
            进队   插入一个元素到队列中， 又叫 入队
            出队    删除一个队列的元素
            
            又称先进先出表
            First In First Out， FIFO， 排队， queue
        基本操作
            InitQueue(q) --- 初始化，将q置为空队列
            QueueEmpty(q) --- 判断是否空队列
            EnQueue(q,e)  --- 将e插入队列q的尾端
            DeQueue(q,e) --- 取走队列q的首元素 送e
            QetHead(q,e) ---  读取队列q的首元素，送e
            QueueCleaer(q) -- 置q为空队列
         
    
    7.11 双队列(deque-- double ended queue)
        1， 双队列，--- 只允许在表的两端插入，删除元素的线性表
        2， 输出受限队列 --- 只许在表的两端插入，在一端删除
        3，输入受限对象 --- 只允许在队列一端插入，两端删除
        
    
    7.12 链式队列
        用带表头的单链表表示队列
        空队列
        非空队列
        满队列
        结点类型
            存放元素的节点类型
        
            由头尾指针组成的结点类型
                头指针，尾指针，链式队列类型
    7.13 假溢出
        1，置队列长度为6
        2，ABC从左侧入队，
        3，ABC出队
        4，DEFG从右侧入队，
        5，G进队报错，溢出，其实现在ABC已经出队，有空间存储G，但是溢出
        
        解决办法:
            1，移动元素，把 DEF移动到前端
            2，将队列q 当作循环表使用，G 将被放入 队首
            
     7.14 二义性
        1, 增加标识变量
        2, 剩下最后一个单元不使用，避免满队列出现二义性
            进队前测试，r+1 = f，则还剩下一个单元
            Q[0, maxleng-1] 共有maxleng-1个元素
     7.15, 空满队列条件
        满队列 r+1 =f 或 f==0 && r == maxleng-1
        (r+1)%maxleng==f 满队列
        
        出队后 空队列条件 f == r
        
        
     7.16, 后缀表达式与中缀表达式转换
        一种方法如a+b*c + (d*e + f)*g 转换为后缀表达式
        1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b*c) ) + ( ((d*e)+f) *g ) )

        2)将运算符移到括号的后面，变成((a(bc)*)+(((de)*f)+g)*)+

        3)去掉括号，得到abc*+de*f+g*+  
        
                 
## 八，数组与广义表
     8.1 数组
        8.1.1 定义
        一维数组的定义
            在C语言中，一维数组不能直接增加长度，只能把值拷贝到一个新的长的数组中进行操作
                也可以采用动态空间分配间接地实现此功能
            递归定义，是一个定长线性表(a1,a2...an)
            记为 A = (a1,a2...an)
            ai 为数据元素，i为下标 1<=i<=n
        二维数组的定义
            定长线性表(b1,b2...bm)
            bi 为行向量， 1<=i<=m,由m个行向量组成
            Bm*n = [[a11,a12...a1n]
                    [a21,a22...a2n]
                    ...
                    [am1,am2...amn]]
            或者由n个列向量组成
            Cm*n = [[a11  ... 
                     a21
                     ...
                     am1] ...]    
            列向量是行向量的列
        三维数组
            定长线性列表(c1,c2...cp)
            ci = (a1,a2...am) 为定长二维数组
            三维数组D[1..3,1..4,1..2] p=3, m=4 n=2
            
            D3*4*2
            表示有 2 页，每一页有 3*4 二维数组 一个
            
        
        8.1.2 操作   
            InitAyyay(&A, n bound1,...boundn)  # 初始化
            DestroyArray(&A)        # 销毁
            Value(A,&e, index1,...,indexn)  # 检索
            Assign(A, e, index1,...indexn)   # 赋值
        
        8.1.3 实现方式
            顺序表示和实现
            一维数组顺序表示
                数组元素ai 的地址计算公式
                LOC(i) = b+(i-1)L=LOC(1)+(i-1)L
            二维数组顺序表示
                A = (a1,a2...an),b是分配的连续存储单元首地址，L是1个数据元素所占单元数
                LOC(i)为元素ai的存储位置二维数组a[1..3, 1..2]
                以行序为主序的顺序存储方法
                    逐行将数组元素放到数据连续性空间，体现在右边下标先变化，左边的下标后变化
                    1,开空间，明确开多大的空间
                        b为首地址，L为每个元素所占存储单元数
                    2,确定摆放方式，行序为主，还是列序为主 (行序逐行摆放，列序逐列摆放)
                    3,分析寻址方式，
                        # n表示每行几个元素，m 表示每列有几个元素
                        按行摆放时，aij 地址为： #i和j表示 矩阵共有多少行多少列
                        # 具体计算的ij值，查具体情况
                        Loc(i,j) = Loc(0,0) + (n*i +j)*L    0<=i<=m-1, o<=j<=n-1
                                 
                        按列摆放时，aij 地址为  
                        Loc(i,j) = Loc(0,0) + (m*j+i)*L
                                 = b+(m*j+i)*L  0<=i<=m-1, o<=j<=n-1
                以列序为主序的顺序存储方法
                    逐列将数组元素放到数据连续性空间，体现在左边下标先变化，右边的下标后变化
                    其他基本思想与行序相同
                    
            三维数组的顺序表示
                A[1..,0..n-1]，行序优先，列序优先
            
            矩阵的压缩存储
                将矩阵的元素按照某种分布规律存储在较小的存储单元中
                1,n阶对称矩阵
                    A3x3 = [[1,2,3]
                            [2,3,4]
                            [3,4,5]]
                    aij = aji  1<=i, j<=n
                上三角即 135 对角线的右上部分
                下三角即 135 对角线的左下部分
                
                下三角元素aij 满足i>=j，
                对称矩阵需要存储的数据元素个数 = 1+2+..+n = n(n+1)/2
                
                2, 压缩矩阵位置计算
                设aij在下三角 i>=j
                因: 第1～i-1共有元素 1+2+3+...(i-1)=i(i-1)/2 个
                ai1~aij有j个元素， 
                得: aij序号为k=i(i-1)/2 +j
                
                有公式如下
                该公式为在SA中的映象函数，下标转换公式
                    k = {i(i-1)/2 +j i>=j
                         j(j-1)/2+i  i<j} # 二选一
                或   
                    A[i,j] = {SA[i(i-1)/2 +j]  i>=j
                             SA[j(j-1)/2 +i]  i<j}
                 
                三对角矩阵
                    A5x5 = [[1,2,3,0,0]
                            [2,3,4,5,0]
                            [3,4,5,6,7]
                            [0,5,6,7,8]
                            [0,0,7,8,9]] 
                    1，元素aij 在三对角的条件 |i-j|<=1
                    2, 三对角的需要保存的元素个数  3n-2
                    
                    存储方式
                        行序为主
                            顺序存储非0元素到 SA[1..3n-2]
                        列序为主
                            顺序存储非0元素到 SA[1..3n-2]
                        那么任意三对角元素aij， 在SA中的序号
                            k = (3*(i-1)-1) + (j-i+2) = 2i+j-2
                            A[i,j] = {SA[k]  |i-j| <= 1
                                      0   其他}
                稀疏矩阵的压缩存储
                    定义:
                        非零元素个数远小于矩阵元素总数
                    压缩存储方法:
                        三元组表
                        十字链接表
                        行逻辑链接顺序表
                    三元组表，稀疏矩阵M及其转置矩阵T
                        
                    稀疏矩阵M，(6,7)行列数，非零元素7
                        M6x7 =[[0,0,0,1,0,0]
                            [0,0,1,0,0,93]
                            [2,0,0,1,0,0]
                            [0,0,0,0,0,0]
                            [0,0,21,0,0,89]] 
                    c语言定义三元组顺序类型
                    # define MAXSIZE 10000
                    typedef struct {
                        int  i,j; //非零元行，列下标
                        ElemType e;
                        } Triple; 定义二元组
                    typedef struct {
                        Triple  data[MAXSIZE+1];
                        int mu, nu, tu;
                        } TSMatrix; 定义三元组顺序表
                    TSMatrix M;
                十字链接表
                    M =  {25,0,0,64
                          0,-8,0,0
                          20,0,0,0}
                当要进行矩阵的加、减、乘等运算时，有时非零元素的位置会发生很大的变化，三元组表位保持以行或列序为主而大量移动元素，
                    十字链表就比较灵活，它在三元组表的基础之上（元素e、行row、列col），多了两个指针域down和right（名称随意），
                    right指向同一行中的下一个非零元素，down指向同一列的下一个非零元素

        8.1.4 转置矩阵算法
            根据M的三元祖顺序表得到T的三元组顺序表
            void TransMatrix(TSMatrix &T)
            T.mu=M.nu;T.nu=M.mu;T.tu=M.tu;
            if(T.tu)
            {
            q=1;  #// 指向T写时的位置
            for(col=1;col<=M.nu;++col)  #//扫描M的三元组表M.nu次
                for(p=1;p<=M.tu;++p)   #//扫描M的长度为M.tu的三元表
                    if(M.data[p].j==col)
                        {T.data[q].i=M.data[p].j;
                        T.data[q].j=M.data[p].i;
                        T.data[q].e=M.data[p].e;
                        q++;}   
            }       # 时间复杂度 O(M.nu*M.tu)   
            
            改进算法
            # num 用户存储初始非零元素的 位置和个数，初始算法时间复杂度 O(M.nu)
                计算个数算法复杂度 O(M.tu)
            # cpot  初始算法时间复杂度 O(M.nu)
            void TransMatrix2(TSMatrix &T)
            T.mu=M.nu;T.nu=M.mu;T.tu=M.tu;   
            if(T.tu)
            { for(col=1;col<=M.nu;++col) num[col]=0;
              for(t=1;t<=M.nu;t++) ++num[M.data[t].j];
              cpot[1] = 1;   # 计算数组cpot
              for(col=2;col<=M.nu;col++) cpot[col]=cpot[col-1]+num[col-1];
              for(p=1;p<=M.tu;++p){  # 扫描M三元组表
              col=M.data[p].j;    # 确定当前M元素列号
              q=cpot[col];   # 确定在T的存放位置
              T.data[q].j = M.data[p].i;
              T.data[q].i = M.data[p].j;
              T.data[q].e = M.data[p].e;
              ++cpot[col];  #修改T的当前行下一元素存放位置
              
              } 
            } # 时间复杂度: O(M.nu+M.tu) 空间复杂度:O(M.nu)
            
     8.2 广义表
        8.2.1定义
            也称列表，是 n(n>=0)个元素的有限列表
            记为: LS=(a1,a2...an)
            LS 为表名， n LS的长度
            大写字母表示广义表名称，小写字母表示数据元素
            
            原子:当广义表LS元素是一个数据元素时，这个元素称为原子
            子表: 广义表LS元素 不是数据元素时
            
            非空表:
                表头(head): 称第一个元素a1为LS的表头(head), 表头可能是原子也可能是嵌套的广义表
                表尾(tail): LS中除了表头的其余部分(a2,...,an)， 表尾一定是广义表
                
            空表:
                A = ()空表，长度为0，即 GLsitLength(A) = 0
                A1 = ((), ((),())) # 非空表， GLsitLength(A1) = 2
            表头表尾为空表的广义表
                广义表的表头为空，并不代表该广义表为空表。
                例如：
                广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；
                而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()
                广义表Ls(()); Ls 的元素为1，head(Ls)为空，但是Ls不为空。
                广义表Ls1();表示Ls1为空表。
         8.2.2 特征举例:
                B =(e)   # 长度 GLsitLength(B)=1
                    Head(B) = e, Tail(B) = ( )
                C = (a,b,c)
                    Head(C) = a
                    Tail(C) = (b,c)
                    Head(Tail(C)) = b
                    Tail(Tail(C)) = (c)
                D = (c,f,(d,e))
                    Head(D) = c
                    Tail(D) = (f,(d,e))
                    Tail(Tail(D)) = ((d,e))  # 注意有嵌套广义表
                    
         广义表可以共享子表
         广义表可以递归
         广义表的图形表示
            ☐ 表示原子
            ○ 列表，若有表名，附加表名
            
            F 多层次的图形或树形
                A
                B
                    e
                C
                    a,b,c
                d
         8.2.3 基本操作
            1, InitGLsit(&L)    # 创建空广义表 
            2, CreateGLsit(&L, S)    # 根据S的定义创建广义表
            3, DestroyGLsit(&L)    # 销毁一个广义表
            4, GLsitLength(L)    # 求广义表长度          
            5, GetHead(L)   # 求广义表头
            6, GetTail(L)  # 求广义表尾
            7, GListDepth(L)  # 求广义表深度，嵌套深度
                   D5 = （）
                   GListDepth(D5) = 1
                   D6 = (c,f,d,e)
                   GListDepth(D6) = 1
                   D7 = (c,f,(d,e))
                   GListDepth(D7) = 2
         
         8.2.4  广义表的存储结构
            表中元素有不同结构，一般用链式存储结构
            由于广义表的元素既可以是原子，也可以是广义表，所以有原子结点和列表结点
            原子结点结构如下: 只有两个域
                tag=0       # 标识域
                atom=元素    # 值域
            列表结点结构如下: 3个域
                tag=1       # 标识域
                hp=表头       # 表头指针域
                tp=表尾     # 表尾指针域
            * 共用体(联合) 统一管理广义表的结点类型,C代码如下:
            typedef struct GLNode{
                ElemTag tag;  # 标识域，区分原子结点和表结点
                union {AtomType atom; # 原子结点
                    struct {struct GLNode *hp,*tp;
                        } ptr;  # 表结点
                    }
            }   *Glist;
            
## 九，树和二叉树
    9.0 数据结构分类
        线性结构
            线性表，栈，队列，串，数组，广义表
        非线性结构                        
            树，(堆)二叉树，图，网
    树/层次关系结构的典型实例
        人物家谱结构，社会组织结构，文件目录结构，html文档...
    9.1 定义
        1，树 tree
            树是n(n>=0)个结点的有限集T
            当n=0时，T为空树
            当n>0时,
                1, 仅有一个称为T的根结点
                2, 当n>1时，余下的结点分为m(m>0)个互不相交的有限集T1,T2...Tm
                   每个Ti(1<=i<=m)也是一颗树，称为根的子树
        举例以下为 5 个结点的树
            以下为 三度树示例
            A           -- 一层
                B,b     -- 二层
                C       -- 三层
                D       -- 四层
                
        2，结点的度 degress
            结点的子树 数目
        3，树的度
            常说的 3 度树，表示树内各结点的度的最大值.（结点拥有的子树数称为结点的度）
            
            树中各结点的度的最大值就是**树的度**
            特点：
                树中结点数 = 总分叉数(所有结点的度之和) + 1
                
                3.1 度为1的结点表示有1个出边
                3.2 叶子度为0，所以没有出边
                3.3 边数 = 所有结点的度之和
                3.4 结点个数 = 边数 + 1
                3.5 例
                    树T0的度为4，其中度为1，2，3，4的结点个数分别为4，2，1，1
                    T0的叶子数是多少？
                    根据以上特点 边数m = 1*4+2*2+3*1+4*1 = 15
                    结点个数 n = m+1 = 16 (因为连接m条边，连接的就是m+1个点)
                    所有结点 减去 非叶子结点（度 不为 0）数，剩下的就是度为0的叶子结点
                    叶子结点 ny = n - 4-2-1-1 = 8,有8个叶子结点
                
        4，n度树
            度为n的树
        5，叶子(终端结点)
            度为 0 的结点
        6，分枝结点(非终端结点，非叶子)
            度不为0 的结点
        7，双亲(父母 parent) 和孩子(child)
            若结点C是结点P的子树的根，则称P是C的双亲，C是P的孩子 child
        8，结点的层 level
            规定树T的根的层为1，其余任一结点的层等于其双亲的层加1
        9，树的深度 depth，高度
            树中各结点的层的最大值
        10，兄弟 sibling
            同一双亲的结点之间 互为兄弟
        11，堂兄弟
            同一层号的 结点互为 堂兄弟
        12, 祖先
            从树根到某结点所经分 枝上的所有结点，为该结点的祖先
        13，子孙
            一个结点的所有子树的结点为该结点的子孙
        14，有序树
            任一结点的各颗子数，规定从左到右是有次序的，即不能互换位置
        15，无序树
            任一结点的各颗子数，规定从左到右是无次序的，即可以互换位置    
        16，森林
            m(m>=0)颗互不相交的树的集合
            任何一颗非空树可表示为一个二元祖 Tree=(root,F)
            其中 root为根结点，F被称为子树森林
            F={T1,T2...}
    9.2 树的基本操作
        9.2.1 查找:
        Root(T)                 # 求树的根结点    
        Value(T,cur_e)          # 求当前结点元素值
        Parent(T,cur_e)         # 求当前结点双亲结点
        LeftChild(T,cur_e)      # 求当前结点 最左孩子
        RightSibling(T,cur_e)   # 求当前结点右兄弟
        TreeEmpty(T)            # 判断树是否空
        TreeDepth(T)            # 求取树的深度
        TraverseTree(T,Visit())  # 遍历
            按某种规则访问T的每一个结点一次且仅一次的过程    
        求结点的层号，度
        求二叉树T的深度
        求二叉树T的叶子/非叶子...
        
        9.2.2 插入类:
        InitTree(&T)        # 初始化置空树
            T = {}
        CreateTree(&T,definition)  # 按定义构造树
            哈夫曼树，二叉排序树，平衡二叉树，堆
        Assign(T,cur_e,value)   # 给当前结点赋值
        InsertChild(&T,&p,i,c)  # 将以c为根的树插入为结点p的第i颗子树
        插入一个结点    
        
        
        9.2.3 删除类:
        ClearTree(&T)           # 将树清空
        DestroyTree(&T)         # 销毁树的结构
        DeleteChild(&T,&p,i)    # 删除结点p的第i颗子树
        删除一个结点
        
        9.2.4 转换
            二叉树  <--> 树
            二叉树 --> 平衡二叉树
            
        
    9.3 树的结构与线性结构对比
        线性结构
            第一个数据元素，无前驱
            最后一个数据元素，无后继
            其他， 一个前驱，一个后继
        树型结构
            根结点， 无前驱
            多个叶子结点，无后继
            其他数据元素，一个前驱，多个后继
        
    9.4 二叉树
        9.4.1 定义
            递归定义，二叉树是n(n>=0)个结点的有限集
            或由一个根结点 和两颗分别称为左子树和右子树的互不相交的二叉树组成
        特点
            每个结点至多 二棵子树(不存在度大于2的结点)
            二叉树的子树有左右之分，且其次数不能 任意颠倒
            
        
        9.4.2 二叉树的五种形态
            T1，  空集
            T2    只有根结点
                A
            T3   有根结点和左树
                A
              a1
            T4   有根结点和右树  
                A
                   a2
            T5   有根结点和左右树
                A
              a1  a2
        9.4.3 二叉树和2度树的区别
            二叉树可能有 五种形态，因为包括了结点的 左右方向
            2度树有4种形态
        9.4.4 三个结点不同形态的二叉树 5种
            T1         T2    T3   T4     T5
            A          A     A    A      A
           B  C       B    B         B     B  
                     C       C    C          C
        9.4.5 三个结点不同形态的树 2种
            T1         T2
            A          A
          B   C        B
                       C    
               
        9.4.6 二叉树的性质和特殊二叉树
        1，二叉树第i层至多有2**(i-1) 个结点 i>=1
            可用归纳法证明
        2，深度为k的二叉树的最多有2**k -1 个结点
            叶子的数目 = 度为2的结点数目 +1
            n_0 = n_2 + 1
        3, 二叉树中，终端结点数n_0 与度为2的结点数 n_2有如下关系
            n_0 = n_2 + 1
        
        9.4.6 满二叉树 full binary tree
            深度为 k 且有2**k - 1个结点的二叉树
            
            1，每一层的结点树都达到最大，叶子结点都在第k层
            2，度为1的结点n_1 = 0
            3, n个结点的满二叉树深度=log_2(n+1)
               设深度为k，因 2**k - 1 = n, 2**k = n+1
               所以 k = log_2 (n+1)  # 以2为底 n+1 的对数
        9.4.7 顺序编号的满二叉树 full binary tree
            从根结点起从上到下逐层(层内从左到右)
            对二叉树的结点进行连续编号
            设满二叉树有n个结点，编号1，2,...,n
            特征:
                1，左小孩为偶数，右小孩为奇数
                2，结点i的左小孩是2i， 2i<=n; 结点i的右小孩是2i+1, 2i+1 <= n;
                3，结点i的双亲是 [i/2], 2<= i <=n
                4，结点i的层号 = [log_2 i] + 1 = [log_2(i+1)]  1<=i<=n
                
        9.4.8 完全二叉树(顺序二叉树)
            如下T8和T9是形状为深度为3的完全二叉树
            以下为深度为3的满二叉树
                1
              2    3
            4   5 6  7
            
            深度T6和T7， 分别为1和2的完全二叉树, T_5不是完全二叉树
                T6      T7      T_5
                1       1        1
                      2            2
                      
            深度为3的完全(顺序)二叉树
                T8          T9
                1            1
              2   3       2     3
            4   5        4  5 6
            
            定义:
                深度为k 有n个结点的二叉树，
                当且仅当 
                每一个结点都与同深度的满二叉树中编号从1到n的结点一一对应
                
            满二叉树一定是完全二叉树
            但是 完全二叉树不一定是 满二叉树
            哈夫曼树是二叉树，但不一定是完全二叉树
            深度为k的完全二叉树性质
                1， 任意结点，左右子树的深度分别表示为 Lhi 与 Rhi
                    Lhi - Rhi = 0 | 1   # 左深度-右深度 为0，1 表示该结点只有 1个或2个子结点
                    即叶结点只可能出现在层次最大或 第二大的两层上
                2, 完全二叉树结点个数n 满足
                    2**(k-1) - 1 < n <= 2**k -1
                3，结点数为n的完全二叉树，深度为
                    [log_2 n] + 1 = [log_2(n+1)]  # 与满二叉树一致 
                
                4，若对含n个结点的完全二叉树从上到下从左至右进行1到n编号
                    如 树 T1
                      A1      # 从上到下
                  B2      C3    # 从左到右
                 D4 E5  F6      # 从左到右
                上面的二叉树最后一个非终结点编号是多少？
                    # 终结点的左双亲结点 编号/2   
                则对完全二叉树的任意一个编号i的结点
                    1), i=1时，则该结点是二叉树的根，无双亲，
                        否则，编号为[i/2]的结点为其双亲结点，下取整
                    2), 2i>n时，该结点无左孩子
                        否则，编号为2i的结点为其左孩子的结点
                    3), 2i+1>n, 则该结点无右孩子结点
                        否则，编号为2i+1的结点为其右孩子结点
        9.4.9 二叉树的存储结构
            1，顺序结构
                使用一维数组存储完全二叉树
                # define MAX_TREE_SUZE 100   # 二叉树最大结点数，包括二叉树中的空位置，需要用0占位
                typedef TElemTyoe SqBiTree[MAX_TREE_SIZE]  #0号单元存储根结点
                SqBiTree bt;
                如上 T1的顺序存储结构
                    ACDBEF //
                    012345 6
                
            1.1 顺序存储特点
                用一组地址连续的存储单元，以层序顺序存放二叉树的数据元素，结点相对位置蕴含结点之间的关系
                
                如 完全二叉树 T2
                      A1      # 从上到下
                  C2      D3    # 从左到右
                 B4 E5  F6   G7   # 从左到右
                        
                ACDBEFG //
                0123456 7
                
                顺序存储有以下特点:数组从 1 编址，i=3
                bt[i]双亲[3/2] = 1,即在bt[1]中
                其左孩子在bt[2i] = bt[6]中
                其右孩子在bt[2i+1] = bt[7]中    
            1.1.10 一般二叉树
            按照完全二叉树的形式存储，没结点的地方用0表示，表示 '虚拟结点'
            如 一般二叉树 T3
                      A1      # 从上到下
                  B2      C3    # 从左到右
                 D4 0   0   G7   # 从左到右
            
            T3的顺序存储结构            
                ABCD00G //
                0123456 7        
            1.1.11 右单支树
            T4 右单支树
            A 1
              B 3
                C 7
                  D 15        
            
            T4顺序存储
            A0B000C000 0 0 0 0 D
            123456789101112131415    
            1.1.11  顺序存储特点
                1，浪费空间
                2，插入删除不方便
            
            2，链式存储结构
                二叉链表  1child-data-rchild
                二叉树链式存储，也称为左孩子右兄弟存储结构
                 （ _表示有左孩子指针,^表示没有右孩子）
                A  --- >  _ A ^
               B --- >  _ B ^
              C --- >  _ C ^
             D  --- >  ^ D ^
             
             优点 1，不浪费空间，2插入删除方便 
            
            3，二叉链式存储
                含n个结点的二叉链表中，有n+1个空链域
                证明：
                    有n-1个结点有链引入，所以非空链域数为 n-1 
                    有n个结点有2n个链引入，所以空链域数为 n+1 
               T5 二叉链表     
                _ A _
            _B_       _C_
          ^D^  ^E^       _F^
                       ^G^  
                 二叉树的层次遍历
                    1，使用队列 数据结构
                    2，访问根结点，并归入队列
                    3，队列不为空，重复下列操作
                        3.1, 从队列取出一个结点
                        3.2, 若其有左孩子，访问左孩子，并归入队列
                        3.3, 若其有右孩子，访问右孩子，并归入队列
                              
            4，三叉链表（二叉链表基础上增加了双亲指针）    
                parent-1child-data-rchild
             二叉树T6如下：
                A
             B    C
            D E     F
                   G
            T6的三叉链表为：(&表示双亲指针，_表示有孩子，^表示没有这一方的孩子)
                &_ A _
            &_B_       &_C_
          &^D^  &^E^       &_F^
                       &^G^ 
                       
          问题:
          1，含n个结点的二叉链表中，有n+1个空链域
          注意树 和链表的关系: 
            树是数据结构，二叉链表是数据的存储结构
            1.1, n个结点有几个链域，  2n个
            1.2, n个结点(顶点)树有几边？    n-1个边
            1.3, 边和链域有什么关系？  链域 = 2* 结点数 = 2(边数+1)
          
          2, 含n个结点的二叉树使用三叉链表存储结构，有多少个空链域？？？ （ppt 40页）
            n个结点有 3n 个指针，有n-1个边，有2(n-1)个指针
            所以空链域 k = 3n - 2(n-1) = n+2
          3, 二叉树的叶子数 与 度为2 的结点数有什么关系
             因为二叉数的结点 度数 只能是 0，1，2
             设 二叉数 结点数为 m， 边为a， 度为1的结点数 n1，度为2的结点数 n2
             叶子数为m1， n1+n2+m1 = m
             a = n1+n2+m1 - 1
             同时 边数 也等于 n1 + 2*n2 (因为度为1的结点表示有1个出边)
             a = n1 + 2*n2
             所以
             n1 + 2*n2 = n1+n2+m1 - 1
             叶子数 m1 = n2 + 1
             答:叶子数 等于 度为2 的结点数 +1               
        9.4.10 线索链表  
            为了利用空链域而出现的
            
        9.4.10.1 遍历二叉树
        ~1，遍历 是任何类型均有的操作，
            线性结构而言，只有一个路径(每个结点只有一个后继)
            二叉树，非线性结构，遍历可以选择路径，有'搜索路径'的问题
            
        按某种规则访问二叉树的每一个结点一次且仅一次的过程
            二叉树一次遍历后，使树中结点的非线性排列按访问先后顺序变为**某种线性排列**
        遍历是树结构 插入，删除，修改，查找运算的基础
        ~2，过程
            设 D 为访问根结点，输出跟结点
            L 为递归遍历左子树，R为递归遍历右子树
        9.4.10.1.3，规则
            二叉树T
                A
             B      C
          E    F       D
                      G
            
            二叉树表示算术表达式f()= (A/B)*C*D+E
                +
                  E
              *
                D
            *
              C
          /
            B
        A
        ~3.1，先左后右
            树的遍历过程会访问 双亲结点多次，入栈一次，出栈一次
            递归的实现简明精炼，但是效率低，某些高级语言不支持递归
            ~3.1.1 DLR 先序遍历 (先根，preorder)
                前序遍历（中左右）
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,访问根结点；2,先序遍历根的左子树;3,先序遍历根的右子树
                例1，以上二叉树 T的访问顺序为: A BEF CDG
                例2，算术表达式的先序遍历结果: +**/ABCDE  (前缀表示法，波兰式)
                    
            ~3.1.2 LDR 中序遍历 (中根，inorder)又称非递归算法
                中序遍历（左中右）
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,中序遍历根的左子树;2,访问根结点;3,中序遍历根的右子树
                例1，以上二叉树 T的访问顺序为: EBF A CGD   #这里顺利奇怪，固定从左到右？
                例2，算术表达式的中序遍历结果: A/B*C*D+E  (中缀表示法)
                非递归实现:
             * 空指针也进栈
             1，设置栈S存放所经过的根结点指针信息，初始化S
             2，遇到根结点并不访问，而是入栈
             3，中序遍历它的左子树
                左子树遍历结束后，将根结点指针退栈，并访问根结点
                然后中序遍历它的右子树
             4，当需要退栈时，如果栈为空则结束
             
             此非递归实现的中序算法，栈中结点都没有被访问
             跟先进栈，左孩子紧随其后进栈，右孩子左根出栈后入栈
             每个结点都进一次，出一次栈，且总是访问栈顶元素
             时间复杂度为 O(n)，
             空间复杂度最大O(n) 即<= O(n)
                        
            ~3.1.3 LRD 后序遍历 (后根，postorder)
                后序遍历（左右中） 最后一定为根
                递归定义:
                    若二叉树为空，遍历结束
                    否则执行: 1,后序遍历根的左子树;2,后序遍历根的右子树;3,访问根结点
                例1，以上二叉树 T的访问顺序为: EFB GDC A   # 这里顺利奇怪
                例2，算术表达式的后序遍历结果: AB/C*D*E+  (后缀表示法 逆波兰式)
                
            ~3.1.4 层序顺序遍历
                层序遍历算法，循环处理，当孩子为空，空指针不入队列 
                时间复杂度 和 空间复杂度均为: O(n)
                按从上到下逐层，同层从左到右的次序访问各结点
                访问根之后，通过根访问其左孩子，然后右孩子
                采用队列数据结构
                例，算术表达式的层序遍历结果 +*E*D/CAB
            ~3.1.5 应用
                1，创建建立(生成)二叉树的存储结构
                    输入: 带空结点的二叉树的先序序列
                    输出: 二叉树的根指针
                    非递归实现:
                        输入: 各结点的值及其在满二叉树中的编号
                        输出: 二叉树根指针
                2，基于遍历序列构造二叉树
                3，求二叉树的深度(后序遍历)
            问题:
                由一颗二叉树的先序序列和中序序列可唯一确定这颗二叉树
                如果知道先序(或后序) 和中序 遍历结果，是否可以恢复出二叉树？  # 可以
                例1:
                    已知二叉树
                    中序序列 BDCEAFHG
                    后序序列 DECBHGFA
                    则 由后序遍历特征，根结点必然在尾部 A
                    由中序特征，根结点必然在中间，左部为左子树，右部为右子树
                    最后，后序DECB子树，确定B为A的左孩子，根据HGF子串，F为A的右孩子
                     A
                  B     F
                   C      G
                  D E    H  
        ~3.2 先右后左
            DRL 逆序遍历
            RDL 逆中序遍历
            RLD 逆后序遍历
        ~3.3 遍历树度应用(重要)
            * 给定二叉树的先序序列，不能唯一确定一个树结构
            * 给定先序(或后序) 和中序，可以唯一确定一个树结构
            
            例1:创建二叉树
            1，创建建立(生成)二叉树的存储结构
                输入: 带空结点的二叉树的先序序列
                输出: 二叉树的根指针
                非递归实现:
                    输入: 各结点的值及其在满二叉树中的编号
                    输出: 二叉树根指针
            2，基于遍历序列构造二叉树
            3，求二叉树的深度(后序遍历)
            
            例2:求二叉树的深度(基于后序遍历)
            基本思想:受限分析二叉树的深度和它的左，右子树深度之间的关系
            
                     A
                  B     F
                   C      G
                  D E    H 
            创建一个函数
                * 输入二叉树的根结点
                * 输出为二叉树的深度
            函数步骤:
                1,判断二叉树树否为空；
                2,左子树的深度；
                3,右子树的深度；
                4,判断左右子树的大小，返回 大的+1 作为二叉树的深度；(由二叉树深度的定义得来)
                
        9.4.10.2 线索二叉树
        ～2.1 遍历二叉树是按某种规则将非线性结构的二叉树结点线性化
        1，遍历二叉树可得到结点的一个线性序列，在线性序列中，就存在结点的前驱和后继，
            但是在二叉链表上只能找到结点的左孩子，右孩子
        2，二叉树结点没有响应的前驱和后继信息
            结点的前驱和后继只有在每次遍历时动态产生
            能否通过结点的两个链域查找出任一结点的前驱和后继？
        
        ～2.2 二叉链表的特点:
        1，n个结点的二叉链表，
            有 2n个指针域，除根以外，使用 n-1个指针,每个结点被一个指针指向
        2，空指针域数 = 2n - (n-1) = n+1
        线索二叉树:
            利用n+1个空链域存放结点的前驱和后继信息       
            
        例:
              A
          B       E
           C     F
         D      G
              H  K
         
        ～2.3 线索二叉树的定义和特征
        定义:
        有先序序列  ABCDEFGHK，指向该序列中的前驱和后继的指针称为线索
        分析结点结构，在二叉链表中增加Ltag 和Rtag两个标志域
            Ichild  Ltag data Rtag rchild
        考虑结构左子树
            有，则左链域Ichild指示其左孩子 Ltag=0
            否，令左链域指示其前驱 Ltag=1
        考虑结构右子树
            有，则右链域Rchild指示其右孩子 Rtag=0
            否，令右链域指示其后继 Rtag=1 
        整体结构 （思考空二叉树线索链表形态）
            增设一个头结点，令其Ichild指向二叉树的根结点Ltag=0，Rtag=1
            并将该结点最为遍历访问的第一结点的前驱和最后一个结点的后继
            最后用头指针指示该头结点
        ～2.4 空二叉树的线索链表
            只有一个头结点，Ltag=0，Rtag=1，Ichild与rchild都指向头结点自身
            _ 0 _ 1 _      
        * 称以这种BiThrNode(左右指针，左右标志)结点结构 构成的二叉链表 称为二叉树的线索链表
        * 指示前驱和后继的链域为 线索
        * 假设线索的二叉树 称为 线索二叉树
        * 对二叉树以某规则遍历使其变成线索二叉树的过程称为线索化
            # 中序/先序/后序 遍历得到的线索二叉树 称为 中序/先序/后序 线索二叉树
            # 先序 线索二叉树：线索指向先序遍历中前驱，后继的线索二叉树
            # 中序 线索二叉树：线索指向中序遍历中前驱，后继的线索二叉树
            # 后序 线索二叉树：线索指向后序遍历中前驱，后继的线索二叉树   
            # 后序后继线索二叉树：只设指向后序遍历中后继线索的线索二叉树
        ～2.5 线索链表遍历算法 (无需堆栈)
        由于在线索链表中添加链遍历中得到的前驱和后继的信息，从而简化链遍历算法
        对中序线索链表的遍历算法，
            ** 有后继找后继，没有后继找右子树的最左子孙
            中序遍历的第一个结点：左子树处于最左下没有左子树的结点     
            中序线索链表结点的后继：若无右子树，则为后继线索指结点
            否则为对其右子树进行中序遍历时访问的第一个结点
            步骤：
            1，设置搜索指针p
            2，寻址中序遍历的 首结点(最左下角结点) Ltag=0时 表示有左孩子
                p=p->child直到LTag=1(无左孩子，已经到最左下角)首先访问p->data
            3,接着进入该结点的右子树，检查RTag和p->rchild
            4,若该结点的RTag=1（表示有后继线索）则p=p->rchild,访问p->data。重复4直到后继结点RTag=0
            5,当RTag=0时，表示有右孩子，则应该从该结点的右孩子开始p=p->rchild，查找左下角子孙结点，即重复2
        ～2.6 建立线索链表(顺序栈)
        在中序遍历过程中修改结点左，右指针域，保存当前访问结点的前驱，后继信息
        遍历过程中，附设指针pre，并始终保存指针pre指向当前访问的，指针p所指结点前驱
        * 每次只修改前驱结点的右指针(后继)和本结点的左指针(前驱)
        若p->ichild = NULL,则 //p的前驱线索应存p结点的左边
        若pre->rchild = NULL, 则//pre的后继线索应存pre结点的右边
        
        ～2.7 画先/中/后序线索二叉树的线性链表

    9.5 树和森林
        9.5.1 树的存储结构
        有树如下
            A
        B   C    D
           E  F
              G
        双亲表示法/顺序表示法/数组表示法
            便于不便于访问孩子结点
            一维数组存储每个结点，每个单元存储结点的值，和双亲的位置域(-1)
            data   A    B   C   D   E   F   G
            parent -1   0   0   0   2   2   5
            r=0   n=7  # n为树的度
        孩子表示法/单链表示法
            固定/非固定 大小结点格式
            很容易访问一个结点的孩子，访问双亲不容易
            
        孩子链表表示法
        带双亲的孩子链表表示法
            带双亲结点的位置域
        树的二叉链表(孩子-兄弟)存储表示法
            根结点的右指针为空
            左指针表示孩子
            右指针表示兄弟
            左右指针都是空时，为叶子结点
            
        树和森林的遍历
        1，树的遍历
            R
         A  B  C
       D  E    F
             G H K
             
        1.1, 先根遍历，若树为空，则空操作
            1),访问树的根结点
            2),依次先根遍历每颗子树
        上图树的 先根遍历序列: RADEBCFGHK
        1.2, 后根遍历，若树为空，则空操作
            1),依次后根遍历每颗子树
            2),访问树的根结点
        上图树的 后根遍历序列: DEABGHKFCR
        2，森林的遍历
        先序遍历森林(相当于对应的二叉树进行先序遍历)
            森林为空，则空操作，否则
            1),访问第一颗树的根结点
            2),先序遍历第一颗树中根结点的子树森林
            3),先序遍历除去第一颗树后余下的树构成的森林
        中序遍历森林(相当于对应的二叉树进行先序遍历) 
            森林为空，则空操作，否则
            1),中序遍历第一颗树根结点的子树森林
            2),访问第一颗树的根结点
            3),中序遍历除去第一颗树后余下的树构成的森林
        3，树的遍历和二叉树遍历的对应关系
            树       森林      二叉树
          先根遍历   先序遍历   先序遍历
          后根遍历   中序遍历   中序遍历      
           
    9.6 树与二叉树的转换(基于树的二叉链表表示，即存储结构为二叉链表)
        1，将树转换为 二叉树
        加线，在兄弟之间加一连线
        抹线，对每个结点，除了左孩子外，去除其余孩子之间的关系
        旋转，以树的根结点为轴心，将整树顺时旋转 45度
        * 原树中 兄弟关系，变成了双亲与右孩子的关系
        * 树转换为二叉树后右子树一定为空
        
        2，二叉树转换为树
        加线，若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子...所有右孩子与p的双亲用线连起来
        抹线，抹掉原二叉树中双亲与右孩子之间的连线
        调整，将结点按层次排列，形成树结构
        
        3，森林转换为二叉树
        将各颗树分布转换成二叉树
        将每棵二叉树的根结点用线相连
        以第一颗树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构
        规则： F为森林集合，二叉树指代用B = (root, LBT, RBT)
            若 F = [], 则B=[]
            否则，
                由ROOT(T1)对应到root
                由F1=(T11,T12...T1m)对应得到LBT
                由(T2,T3...Tn)对应得到RBT
        
        4，二叉树转换为森林
        抹线，将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立二叉树
        还原，将孤立二叉树还原成树
        
        树的各种操作均对应二叉树来操作完成
        和树对应的二叉树，其左右子树的概念已经改变为 左是孩子，右是兄弟
        转换规则:
            若B=[], 则F=[]
            否则
                由root对应得到ROOT(T1)
                由LBT对应得到F1=(T11,T12...T1m)
                T1=(root,T11,T12...T1m)
                由RBT对应得到(T2,T3...Tm)
    
    9.7 哈夫曼树(最佳树/最优树)及其应用
        最优二叉树(Huffman 树)，特点: 总权和最小,判定过程最优
        9.7.1 路径长度
            从树的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作 路径长度
        9.7.2 树的路径长度 PL
            PL(T) 指代 树 T 的路径长度 
            从树根到每一结点的路径长度之和
        9.7.3 树或二叉树T 的带权路径长度 WPL(就是路由与交换里的 OSPF算法，最短路径优先)
            每个子叶的权与根到该叶子的路径长度的乘积之和，记为 WPL(T)
            WPL = 𝚺(k=1,n)w_kl_k
            n 树T的叶子数目， w_k 叶子k的权
            l_k 树T的根到叶子k的路径长度
            以下为树T1(数字表示叶子的权，没有数字表示权为0)
            A
         B     C6
       D3  E
         F4 G9
            则 WPL(T1) = 3*2+4*3+9*3+6*1 = 51   
        9.7.4 特征:
        当n结点的二叉树为完全二叉树时，PL(T)具有最小值
        当n结点的二叉树为单枝树时，PL(T)具有最大值    
        
        9.7.5 最优树
        在具有n个相同叶子的各二叉树中，WPL最小的二叉树
        完全二叉树并不一定是 Huffman树
        在哈夫曼树中权值大的结点离根近(这样WPL才能最小)
        哈夫曼树不是唯一的，但WPL一定相等
        
        9.7.6 Huffman算法
        1,以权值分布为W1，W2...Wn 的n个结点，构成n颗二叉树T1，T2...Tn
          每棵二叉树Ti 仅有一个权值为Wi的根结点
        2, 在F中选取两棵根结点权值最小的树作为左右子树构造一颗新二叉树
          并且置新二叉树根结点权值为左右子树上根结点的权值之和
          根结点的权值 = 左右孩子权值之和
          叶结点的权值 = Wi 
        3, 从F中删除这两棵二叉树，同时将新二叉树加入F
        4,重复2，3直到F中只含一颗二叉树为止(这个就是Huffman树)
        
        5，实例1: 构造哈夫曼树(哈夫曼算法 加 排序)
        给定权集合{4,5,3,6,10},构造哈夫曼树
        5.1，按权值大小排序 3，4，5，6，10
        5.2，生成森林
            3   4   5   6   10
            T1  T2  T3  T4  T5
        5.3，合并两棵权最小的二叉树，并排序，指代一颗为二叉树
          第一步： 合并 3，4
            7
          3   4  5  6  10
          第二步： 排序
          5   6   7   10
                3   4
          第三步：选择合并，排序
          7   10   11  
         3 4      5  6
          第四步：选择合并，排序
         11    17      
        5  6  7  10
             3 4
          第五步：哈夫曼树
             28
          11    17
         5  6  7  10
              3 4
      
       9.7.7 Huffman编码/最小冗余编码
       ASCII编码/定长编码
       as12： 01100001 01100010 00110001 00110010
                97      98          49      50
       哈夫曼码/不定长编码
       能按字符的使用频度，使文本代码总长度具有最小值
       例2：求哈夫曼编码
       给定有18个字符组成的文本 AADATARAEFRTAAFTER
       1）分析统计
           字符  A D  E F T R
           频度  7 1  2 2 3 3
       2）构造Huffman树
           1 2 2 3 3 7
           按照9.7.6 实例1的步骤: 构造哈夫曼树(哈夫曼算法 加 排序)
           最后得哈夫曼树
              18
         7(A)      11
               5         6
           2(F)  3    3(T) 3(R)
             1(D) 2(E)
         得到的哈夫曼树 叶结点根据权值附上字符，分支标数的哈夫曼树
         
       3）构造Huffman 编码
       
           字符   A   D       E   F   T     R
           频度   7   1       2   2   3     3
           编码   0  1010   1011  100 110  111
       0表示左小孩，1表示结点的右小孩 
       哈夫曼编码的特点：
           任一编码不是其他编码的前缀
           哈夫曼树没有度为1的结点
           有n个叶子的结点，则其共有2n-1 个结点
           哈夫曼编码时，是从叶子走到根；
                译码是从根走到叶子，所有每个结点需要增加双亲指针分量
           实现哈夫曼树时，使用顺序和链式两种 存储结构
       
       4) 译码 
       有哈夫曼树如下
              18
         7(A)     11
              5        6
           2(F) 3  3(T) 3(R)
             1(D) 2(E)
       给定代码序列
       0 0 1 0 0 0 1 1 1 0 1 0 1 0 1 0 1 1 1 10
       翻译为文本
       AAFARADET 
        
## 十 图 Graph
    10.1 定义
    图由顶点集V(顶点(元素)的有穷非空集)和关系集 VR(两个顶点之间的关系集合)组成，
    记为  G=(V,VR)
    10.1.1 分类和概念 
    有向图
        有向图，弧(有向边)，若图G任一两顶点a，b之间的关系为有序对(a,b),即(a,b)∈VR
        * 称(a,b)为从a到b的一条弧/有向边， a 是弧尾， b是弧头，# 这里需要特别注意些
        例1：
        G1 = (V1,E1), V1={A,B,C,D,E}
        E1 = {<A,C>,<A,D>,<C,D>,<B,E>,<E,B>}
        称图G1 为有向图,各结点连接线有方向 
    无向图，边(无向边)
        若图G任两顶点a，b之间的关系为 无序对(a,b),则(a,b)为无向边(边)，
        称该图G是无向图，无向图可简称为图
        * (a,b)表示a，b互为邻接点， a,b依附于a和b，(a,b)与a和b相关联，            
        例1：
        G2 = (V2,E2), V2={1，2，3，4，5，6}
        E2 = {<1,3>,<1,5>,<3,5>,<4,6>}
        称图G2 为图 
    完全图
        有n个顶点和n(n-1)/2 条边的无向图，即每个顶点都与其他顶点直接连接
        如果一个无向图有 3个顶点，3个边，就是完全图
        又如 5个顶点，10条边
    有向完全图
        有n个顶点和 n(n-1) 条弧的有向图，就是有向完全图
        如两个顶点A，B 有2个有向线 A->B, B->A
    网 Network
         边(弧)上加权weight的图
         网可以是有向的也可以是无向的，但是每个边必须有权重
    子图
        图G = (V,G) V是顶点，G是顶点之间的关系
        G1 = (V', G'), V'属于V，G'属于G'， 称G1是G的子图
        也就是说如果一个图A的所有顶点和关系都可以在 图B中可以找到，那么A就是B的子图
    图A
        V1 - V2 - V3  V6
            /  \
          V4 - V5    
    度
        与顶点 x 相关联的边(x,y)的数目，称为x的度，记为TD(x) 或 D(x)
        如图A中， D(V1)=1,D(V2) = 4, D(V4)=D(V5)=2, D(V6)=0
    出度
        以顶点x为弧尾的弧(x,y)的数目，称为x的出度记为OD(x)
        V1 <- V2 <- V3   OD(V1)=0,  OD(V2)=1,  OD(V3)=1
         
    入度
        以顶点x为弧尾的弧(x,y)的数目，称为x的出度记为ID(x)
        V1 <- V2 <- V3   ID(V1)=1,  ID(V2)=1,  ID(V3)=0
    TD(V1) = OD(V1) + ID(V1) =1, TD(V2) = OD(V2) + ID(V2) =2      
    连通图 及连通分量 (无向图G)
        从一个顶点出发，一次深度遍历就可以访问到所有顶点
        遍历所得的生成树或序列理论上是不唯一的，但是可以做到唯一
        
        若顶点vi 到 vj有路径，则称vi和vj是连通的
        若图G 任意两顶点是连通的，则称图G是 **连通图** 
        若图G'是G的一个极大连通子图，则称G'是G的一个**连通分量**         
    强连通图 及强连通分量 (有向图G) 7.4.2
        若在图G中，每对顶点vi，vj之间，从vi到vj且从vj到vi都存在路径，则称G是 **强连通图**
        若图G'是G的一个极大 强连通子图，则称G'是G的一个 **强连通分量**
        (强连通图 是自己的强连通分量)
                 
    生成树             
        设G=(V,E), G'=(V',E'), V=V'，若G是连通图，G'是G的一个极小连通子图，
        则G'是G的一棵生成树, 如下所示。T1.T2.T3都是 T0的连通量
            T0              T1            T2          T3
        A - B - C        A - B - C     A - B - C    A   B - C
         \ / \ /            / \           /          \     /
          E - D            E   D         E - D        E - D
                                    
    10.2 特征
        邻接表和邻接矩阵中 对图对顶点 度的算法时间复杂度并不相同
        如有n个顶点，e个弧的有向图，邻接表作为物理结构，求每个顶点的时间复杂度：
            大部分是O(n+e)是对的，O(n*n)是用邻接矩阵存储时的时间复杂度。
            算法就是遍历每一条边，然后把每条边的终点的入度+1.
            在邻接表中，就是要依次访问每个顶点，然后在每个顶点中依次访问每条边，把这些边的终点的入度+1。
            也就是每个顶点和每条边依次要各访问一遍，所以时间复杂度是O(n+e)。
            在邻接矩阵中，算法需要遍历邻接矩阵的每一个点 ，而邻接矩阵有n*n个点，所以时间复杂度是O(n*n)。
    10.3 操作
        1) CreateCraph(&G,V,VR)   #根据顶点集V 和关系集VR生成图
        2）DestroyCraph(&G)    # 销毁图
        3）Locate(G，u)    # 查找顶点u的位置
        4) GetVex(G,v)    # 读取顶点v的信息
        5) PutVex(&G,v,value) #给顶点v的赋值value
        6) FirstAdjVex(G,v) #读v的第一个邻接顶点
        7) NextAdjVex(G,v,w)   # 读v(相当于w)的下一个邻接顶点
        8) InsertVex(&G, v)  #插入顶点
        9) DeleteVex(&G,v)   #删除顶点
        10)InsertArc(&G,v,w) #插入弧(v,w)
        11)DeleteArc(&G,v,w) #删除弧(v,w)
        
        12)DFSTraverse(&G,visit()) # 深度优先遍历图
        13)BFSTraverse(&G,visit()) # 广度优先遍历图
    * 重点 10.4 图的存储结构
        V1    V4
        / \
      V2   V3
        
        4.1 数组表示法/邻接矩阵(顺序+顺序)
            思想
            图的邻接矩阵存储方式是用两个数组来表示图。
            一个一维数组存储图中顶点信息，
            一个二维数组（邻接矩阵）存储图中的边或弧的信息
            * 无向图的邻接矩阵一定对称，有向图的邻接矩阵不一定对称
            
            顶点数组，用一维数组存储顶点(元素)
            如上图 vexs = [v1 v2 v3 v4]
            邻接矩阵--用二维数组存储顶点(元素)之间的关系(边或弧)
            无向图邻接矩阵arcs 其中，1表示有连接，0表示没有
            M=
            [[0 0 1 1
              0 0 0 0 
              1 0 0 1
              1 0 1 0]]
            邻接矩阵arcs i行之和 = 𝚺(j=0,n-1)arcs[i][j]
            邻接矩阵arcs i列之和 = 𝚺(j=0,n-1)arcs[j][i]
            有向图邻接矩阵arcs，1表示出口，0表示入口
            由邻接表可以做以下工作 
                求每个顶点的度 D(vi), 矩阵列宽
                OD(vi),  矩阵行每行的和
                ID(vi)  矩阵列宽 减 矩阵每行的和
            
        4.2 邻接表，逆邻接表(顺序+链式)
            邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。
            因此，找到一种数组与链表相结合的存储方法称为邻接表。
            4.2.1 无向图的邻接表
              为图G的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边
              v0 - v1       V3
              v2           /  \
                          V4  V5
              以上 无向图的邻接表 如下
              序号  头结点数组   表结点单链表
              0     v0 __       1 ^
              1     v1 __       0 ^
              2     v2 ^
              3     v3 __       4 __ -> 5 ^
              4     v4 __       3 __ -> 5 ^
              5     v5 __       3 __ -> 4 ^
              若无向图G有n个顶点和e条边，需要n个表头结点和2e个表结点
              无向图G的邻接表，顶点vi的度为第i个单链表的长度
              
            4.2.2 有向图的邻接表 ↖︎ 
              第i个单链表中的表结点的值为j，表示以顶点vi 为弧尾的一条弧(vi,vj)
              特点:   
                1，若有向图G有n个顶点和e条弧，则需n个表头结点和 e个表结点
                2，有向图G的邻接表，顶点vi的出度为第i个单链表的长度
                3，求顶点vi的入度需遍历全部单链表，统计结点值为i的结点数
                  
            如以下向图 G1                
                A -> B <- C
                ↓  ↗︎     ↙︎ ↘︎
                 D      E ->F
               G1有向图邻接表,只表示出度，如下
               0    A _ -> 1 _ -> 3^
               1    B ^
               2    C _ -> 1 _ -> 4 _ -> 5 ^   
               3    D _ -> 1 ^
               4    E _ -> 5 ^
               5    F ^
            4.2.3 有向网的邻接表
                
                有以下有向网G
                A -5> B <7- C
               4↓ 17↗︎     8↙︎ ↘ 10︎
                 D        E -8>  F
                G的邻接表如下
                         1是序号，5是权值 _为指针
                0   A _ -> 1 5 _ -> 3 4 ^
                1   B ^
                2   C _ -> 1 7 _ -> 4 8 _ 5 10 ^
                3   D _ -> 1 17 ^
                4   E _ -> 5 8 ^
                5   F ^
                
            4.2.4 有向图的逆邻接表
                第j个单链表中的表结点的值为i目标是一条以顶点v1为弧尾的一条弧(vi,vj)
                如上有向图G1, 有以下逆邻接表特征：
                若有向图G有n个顶点e条弧，则需n个表头结点和e个表结点
                有向图G的逆邻接表，顶点vi 的入度为第i个单链表的长度
                求顶点vi的出度，需遍历全部单链表，统计结点值为i的结点数
                序号  头结点数组   表结点单链表
                0       A ^
                1       B _ -> 0 _ -> 2 _ -> 3 ^
                2       C ^
                3       D _ -> 0 ^
                4       E _ -> 2 ^
                5       F _ -> 2 _ -> 4 ^
                                 
            4.2.5 有向图的十字链表
                将邻接表和逆邻接表合并而成的链接表
                1， 每条弧有一个弧结点
                    弧结点 tailvex  headvex hlink tlink
                    tailvex 弧尾的位置， headvex 弧头的位置
                    hlink 指向下一条弧头相同的弧
                    tlink 指向下一条弧尾相同的弧
                2， 每条顶点有一个顶点结点
                    顶点结点 data firstin forstout
                    firstin  指向以该顶点为弧头的第一条弧
                    firstout  指向以该顶点为弧尾的第一条弧
                3，步骤
                    以邻接表为基础，扩展结点树形成岂止结点序号
                    再添加逆邻接表信息 得到十字链表
            4.2.6 (无向图的)邻接多重表
            1，每个顶点有一个头结点
                头结点  data firstedge
                其中  data 顶点信息， firstedge  指向第一条依附于该顶点的边
            2，每条边有一个表结点
                表结点 mark ivex jvex ilink jlink
                其中 mark 标志域，用以标记该条边是否被搜索过
                ivex, jvex 该条边依附的两个顶点在顶点数组的位置
                ilink  指向下一条依附于顶点vi的边
                jlink  指向下一条依附于顶点vj的边
            例: 有图如下
                G                  
            A - B   E
            | / |   |
            C - D   F
            隐含的链接表:
            A -> (0,1) ->(0,2) 
            B -> (0,1) ->(1,2) ->(1,3)
            C -> (0,2) ->(1,2) ->(2,3) 
            D -> (1,3) ->(2,3)
            E -> (4,5) 
            F -> (4,5)
              data     ma  vi  vj  il  jl
            0   A _ -> 0   0   1   _   _  (A,B)
            1   B -  ↗             ↓
            2   C _  -> 0  0   2   ^   _  (A,C)  
            3   D _\    0  1   2   _   _  (B,C)
                    ->  0  1   3   ^   _  (B,D)
            4   E ↘     0  2   3   ^   ^  (C,D)
            5   F  ->   0  4   5   ^   ^  (E,F)
            
        *4.3 重点 图的遍历
            A - B - C
            /\   \ /
           E  F   D
            \/ \
            G - H
            从图G的某定点 vi 出发，访问G的每一个顶点一次且只经过一次的过程
            广度优先用队列，深度优先用栈。简单说明如下：
            广度优先：当一个节点被加入队列时，要标记为已遍历，遍历过程中，对于队列第一个元素，遍历其所有能够能一步达到的节点，如果是标记未遍历的，将其加入队列，从第一个元素出发所有能一步直接达到的节点遍历结束后将这个元素出列。
            深度优先：当遍历到某个节点A时，如果是标记未遍历，将其入栈，遍历它能够一步直接达到的节点，如果是标记未遍历，将其入栈且标记为已遍历，然后对其进行类似A的操作，否则找能够一步直接达到的节点进行类似操作。直到所有能够一步直接达到的节点都已遍历，将A出栈。
            这里使用“能够能一步达到的节点”而非“与其相邻的节点”是考虑到有向图因素。
            手工修改队列和栈就明白了
            4.3.1 图的深度优先搜索 DFS Depth First Search
                A E G F H B D C ...
                不可能顺序  A E C F H B D G  ...
            4.3.2 图的广度优先搜索 BFS Breadth First Search
                从顶点出发，设置访问标记1，顶点入队
                队列非空
                访问与该顶点相邻的并且未被访问的顶点，标记顶点，并使顶点入队                
                循环直到顶点为空
                A E F B G H D C ...
                不可能顺序  A E F B C D H G ...
                
        4.4 图的连通性问题
            无向图的连通分量
            
            生成树
            从不同的顶点出发会有不同的生成树
            DFS生成树
            BFS生成树
            DFS生成森林
            BFS生成森林
            
            有向图的强连通分量
            在有向图G中，从某个顶点v出发顺着弧的方向，进行深度优先搜索遍历，得到顶点集合V1，
            再顶点v出发，G = (V,VR)  V = V1 交集 V2， VR是V中所有顶点在G中的弧
            逆着弧的方向进行深度优先搜索遍历，得到顶点集合v2，这样得到一个强连通分量
            A <- D      A <- D
           ↓↗ ↖↗ ↗     ↓↗  ↗        C
           B <-  C      B
              G         G1          G2
           从A出发，顺着弧方向得到顶点集合 {A,B,D},逆的弧方向的顶点集合{A,B,C,D}
           交集为 {A,B,D}, 加上他们之间所有弧,得到强连通分量G1
           
        * 重点  4.5 网的最小生成树
        在网 G 的各个生成树中，其中各边的权之和的最小的生成树称为G的最小生成树
        网G          生成树T1 权之和13   生成树T2权之和10   ...
          2            2                2
        A - B        A - B            A - B
       1/    \4          \4          1/  
      C       D      C    D          C    D
       4\   /3       4\  /3           4\ /3
          E            E                E
       通过以上定义可知，T2 为 网G 的最小生成树
          
       MST性质-最小代价生成树（Minimum Cost Spanning Tree)（简称为最小生成树）
            设G=(V,E)是一个连通网，Y是V的一个非空子集。如果边(u,v) 是G中所有一端在U中
            而另一端v在V-U中具有最小值的一条边，则存在一棵包含边(u,v)的最小生成树
            
        * 普里姆prim算法 P51
            选顶点为主
            算法适合边稠密的无向连通网 复杂度: T(n,e)=O(n**2)
            对n个顶点对连通网，初始时，T=(U,TE)，U为一个开始顶点，TE=[]
            以后根据MST性质，每次增加一个顶点和一条边，重复n-1次，U不断增大，V-U不断减小直到为空
            
        * 克鲁斯卡尔(Kruskai)算法
            选边为主
            需要将边按递增次序排列，以供选择
            
            算法适合边稀疏的无向连通网 T(n,e)=O(e log e)
        问题
            1，所有边权均不相同的无向图最小生成树是唯一的
            2，同一个图不同最小生成树的边权重序列相同 
            用反证法证明
               
    10.5 有向无环图及其应用
        一个无环的有向图称为有向无环图(directed acyline graph) DAG图    
            
        * 重点 拓扑排序(物理结构是 邻接表) T(n) = O(n+e)
            AOV网(Activity On Vertex network),以顶点表示活动,弧表示活动之间的优先关系的DAG图
            拓扑排序。
            定义:是有向图的全部顶点的一个线性序列，该序列保持了原有向图中各顶点间的相对次序
            思想:
            1，在有向图中选一个没有前驱的顶点输出(选择入度为0的顶点)
            2，从图中删除该顶点和所有以它为尾的弧(修改其他顶点入度)
            3，有回路的有向图不存在拓扑排序
        关键路径
            路径长度最长的路径称为关键路径(Critical Path)
            AOE网(Activity On Edge)
                
                是一个带权的有向无环图，其中以顶点表示事件，弧表示活动，权表示活动持续时间
                AOE网用来估算工程完成时间时，只有一个开始点(入度为0，标为源点)和一个完成点(出度为0，称为汇点)
            AOE网问题
                完成整项工程至少需要多少时间
                    从开始点到v1的最长路径长度 ve(v1)=0
                    完成点(汇点)的ve(vn)为工程完成所需要的时间
                哪些活动影响工程进度关键 
                    l(i) - e(i)表示 完成活动ai的时间余量 
                    l(i)=e(i)的活动
        
        关键路径算法步骤
            1  初始化各顶点最早发生时间0，从开始点v1出发，按拓扑排序序列求其他各顶点的最早发生时间
            Ve(j) = max{ve(i) + dut(<i,j>)}
            vi为以顶点vj为幅头的所有弧的弧尾对应的顶点
            2  从完成点vn出发，令v1(n)=ve(n)按逆拓扑排序序列求其他各顶点的最迟发生时间
            V1(j)=min{(v1(k)-dut(<j,k>)}
            (vk为以顶点vj为弧尾的所有弧的弧头，对应的顶点集)
            3  求每一项活动ai(vj,vk):
            e(i)=ve(j)  l(i)=vl(k)-dut(ai)
                   
        关键活动
            选取e(i) = 1(i)的活动
            关键活动组成了关键路径，关键路径是图中的最长路径，关键路径长度代表整个工期的最短完成时间，关键活动延期完成，必将导致关键路径长度增加，即整个工期的最短完成时间增加。
            关键路径并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只能导致本条关键路径变成非关键路径，而无法缩短整个工期，因为其他关键路径没有变化。
            任何一条关键路径上的关键活动变长了，都会使这条关键路径变成更长的关键路径，并且导致其他关键路径变成非关键路径（如果关键路径不唯一），因此整个工期延长。
            而某些关键活动缩短则不一定缩短整个工期。  
                     
        最短路径
            从某源点到其余各项顶点的最短路径
            狄杰斯特拉算法 Dijkstra路径长度递增法
            
            开始点  终点   最短路径    路径长度
            v0      v1      无        
                    v2    v0,v2        10
                    v3    v0,v4,v3     50
                    v4    v0,v4        30
                    v5    v0,v4,v3,v5  60
                    
        
        每一对顶点间的最短路径
            1，狄杰斯特拉算法 Dijkstra
                以每一个顶点为源点，重复指向Dijkstra算法n次
                迪杰特拉斯算法求解了一个起始节点到所有其他节点的最短路径，时间复杂度为O(n**2) 
                即使人们可能只想知道从起始节点到某个特定的节点的最短路径，时间复杂度同样为O(n**2)
            2，弗洛伊德 Floyd算法
                求Vi到Vj的最短路径,如果vi 到vj有弧，则存在一条长度为arcs[i][j]的路径，该路径不一定是最短路径，尚需进行n次试探
                Floyd-Warshall算法的时间复杂度为O(N**3)，空间复杂度为O(N**2)
        
            
             
## 十一 查找
    11.1 静态查找表
        查找基于数据逻辑结构(D,R)定义的一种十分常见的运算，即确定某数据元素是否在数据元素集的问题
        11.1.1 术语:
            关键字，D={a1,a2...an}的每个数据元素ai有唯一标志的分量，记为ai.key
            一般描述形式 Search(T,key)，即查找key是否在T中
        Search函数
            Search(T,key)返回值或函数值定义为以下三种之一
            1，Search(T,key) = {True, False}  # true表示key在T中，反之亦然
            2，Search(T,key) = {i, 0}  # i表示key在T中 ki=key，0表示key不在T中
            3，Search(T,key) = {p, Null}  # p表示key在T中 ki=key，Null表示key在T中
        静态查找表算法思想
            依次与每个关键字逐个比较，如果给定值相等，查找成功，否则失败
        平均查找长度(Average Search Length)
            成功平均查找长度  ASL = 𝞢(i=1,n)PiCi (pici分别为查找的第i个关键字概率和比较次数，n为表长)
            失败平均查找长度  ASL= 𝞢(i=1,m)QiCi(qici分别为第i种失败概率和关键字比较次数，m为失败情况)
        算法改进:哨兵技术
        有序表查找
            折半查找法，大于给定值，在表左半边查找，小于给定值，在表右部查找
            也称二分搜索（英语：binary search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法
            折半查找法的优点是比较次数少，查找速度快，平均性能好；
            其缺点是要求待查表为有序表，且插入删除困难。
            因此，折半查找方法适用于不经常变动而查找频繁的有序列表
            算法步骤:
            1,计算中间位置；2，用待查关键字比较，相同则返回，小于则查左部，大于则查右部
            3，对确定的区域再按折半公式，重复上述步骤
            存储结构：一般使用一维数组
            时间复杂度log(n)
            画出二叉树，然后把叶子补足。叶子的高度就是查找失败的次数。然后求和除以叶子数目就是失败的平均查找长度
            成功查找长度:
            折半查找判定数中，某结点所在的层数就是即将要比较的次数，
            整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的长度
            n为数据元素个数，((n+1)/n ) *log2(n+1)-1 (其中对数中的2为底数：即log以2为底（n+1)的对数）
                注 : 当n很大时，可近似为 log2(n+1)-1
                n = 11时， ASL_succ = (12/11)log2(12)-1 = 3
            
            ** 失败:
            * 失败最少比对次数的问题？？
            折半查找判定数中，查找不成功的次数即为查找相应外结点与内结点的比较次数。
            整个判定树代表的有序表的平均查找长度。
            查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。
            外结点，所有外界点都是查找不成功的情况,如果有序表的长度为n,则外结点一定有n+1个,即树里叶子的虚拟结点和叶子的兄弟结点
            ASL=(4*5+5*7)/12=55/12;   4～5次
             
        计算中间位置的其他方法
            斐波那契序列法(n=F_u -1) F_u = {0,1, f_u+1 + F_u+2 } （u>1）
            线性插值法
        11.1.2 索引顺序表查找
            分块查找法:
            利用关键字序列分段有序性，建立分段索引表，借助分段索引表，实现快速查找    
            思想: 1，在分段索引表中，顺序或合并的查找给定值所在； 2，在1确定的块中，顺序查找给定值
            复杂度:
            假设索引表的平均查找长度ASL_b, 查找表上平均查找长度ASL_w 则 ASL = ASL_b+ASL_w
            顺序查找: ASL = n**(1/2) + 1
            折半查找: ASL = LOG_2(n/s + 1) + S/2
                
    11.2 动态查找表
        1,二叉排序树
            定义:
            一棵非空树T满足
            1,T的左子树非空，则左子树索引结点值小于T的根值
            2,T的右子树非空，则右子树索引结点值大于T的根值
            那么T的左右子树均为二叉排序树
            查找方案，基于T=(D,R),创建对应的二叉排序树
            查找算法: Locate(T,k)
            1,如果排序树T为空，返回 false
            2,如果排序树T根值>待查找值k，则在T的左子树上递归查找，否则T的右子树递归查找
            插入算法: Insert(&T,k)
            根据关键字k，在排序树T上查找，并在失败处插入之
            创建算法:Create(&T,definit)
            根据DS=(D,R)的关键字序列，对每个关键字k，逐个在排序树T查找，并在失败处插入之
            对于有n个关键字的n! 种排列，对应的二叉排序树高度区间为 log_2 n ~ n
            二叉排序树，删除算法，假设P指向被删除结点
            示例:
                尝试构造二叉排序树(45,12,78,37,24,1,99,61,90,53)，并计算平均查找长度ASL
                ASL_succ = (1*1 + 2*2 + 3*4 + 4*3)/10 = 2.9
                ASL_fail = (3*5 + 4*6)/10 = 3.6
        2,平衡二叉树 Balancwed Binary Tree
            满足以下性质的一棵非空二叉树T
            1，T的左右子树的深度之差的绝对值不超过1
            2，T的左右子树均为平衡二叉树
            二叉树T的结点平衡因子BF(Balance Factor)为左子树的深度减去右子树的深度
            当 T的|BF| <= 1时，T是平衡二叉树
            算法:
                创建算法 Create(&T,definit)
                根据DS=(D,R)的关键字序列，每一个关键字k，逐个在平衡排序树T上查找，在失败处插入，如果T失去平衡，对最小不平衡子树进行平衡化处理
                最小不平衡子树:是从插入结点k到二叉平衡树T的根 路径上，距离结点k最近的，平衡因子绝对值>1的结点为根的子树
                如下 (45,12,78,37,24,1,99,61,90,53)  12-37-24就是最小不平衡子树
                        45
                       /  \
                     12    53
                       \
                       37
                      /
                     24
                平衡化方法
                当平衡排序树T上插入失去平衡时，处理如下
                1。单向右旋，插入点是最小不平衡子树的左子树之左子树
                2。单向左旋，插入点是最小不平衡子树的右子树之右子树 
                3。左旋右旋，插入点是最小不平衡子树的左子树之右子树
                4。右旋左旋，插入点是最小不平衡子树的右子树之左子树
            示例:
                尝试构造平衡二叉树(13,24,37,53,90)，并计算平均查找长度ASL
                ASL_succ = (1*1 + 2*2 + 3*2)/5 = 2.2
                ASL_fail = (2*2 + 3*4)/6 = 2.7
        3,B- 和 B+树
            一棵m阶B-树，满足
            1，树中每个结点至多m颗子树
            2，如果根结点不是叶子结点，至少两颗子树
            3，除了根之外的所有非终端结点至少有 m/2 个子树
            4，所有非终端结点中包含下列数据项目 (n,A0,k1,A1,k2,A3,...kn,An) 
                m/2 <n<m-1为关键字个数,ki为关键字,Ai为指向子树根结点的指针
            5，所有叶子结点在同一层，不带信息
        特征:B- 树是一种平衡多路查找树，除了根结点之外，每个非终端结点含有m/2 ~m颗子树，
        叶子结点是空指针指向的,并不存在实际结点，含义是查找失败的结点,
        四阶B-树：
                    1_38_ _
           1 _ 18 _             2 _ 43 _ 78 _
        1 _ 11 _  1 _ 27 _    1 _ 39 _   2 _ 47 _ 53 _ 64 _  
          F    F    F    F      F    F     F    F    F    F
        B- 查找算法
            根结点开始，没找到进入子树查找，仍然没找到进入叶子结点(空子树)表示查找失败
            时间复杂度，最坏情况 T(N,m) = O(log(m*N)) = O(logN) m为常量时 
        B- m阶插入算法
            从根结点开始，查找待插入key值，直到叶子结点，失败    
        B- m阶删除算法
            先查找待删除的关键字结点，然后在该结点删除关键字k
            终端结点分4种情况处理
            1,终端结点关键字个数 >= m/2
                待删除关键字k和右邻指针直接删除
            2,终端结点关键字个数= m/2-1,右兄弟结点关键字个数 > m/2 -1
                删除k，将右兄弟结点父指针左邻关键字x插入到k之前所在结点，将右兄弟结点中最小关键字m，上移到
                父结点的原关键字x所在位置
            3,终端结点关键字个数= m/2-1,左兄弟结点关键字个数 > m/2 -1
                删除k，将左兄弟结点父指针右邻关键字x插入到k之前所在结点，将左兄弟结点中最小关键字m，上移到
                父结点的原关键字x所在位置
            4,终端结点关键字个数= m/2-1,左右兄弟结点关键字个数 > m/2 -1
                删除k后，加上父结点指向右兄弟结点左邻关键字x，一起合并到右兄弟
                合并后如果父结点关键字个数小于 m/2 -1， 则父结点依次做上述相同结点合并，直到结点关键字个数不小于m/2 -1，
                或直到根结点为止
        B+ 树, 是B-树的变形
            差别在于1，n颗子树中含有n个关键字
            2，所有叶子结点中包含全部关键字信息，及指向含有这些关键字记录的指针，叶子结点依关键字大小顺序链接
            3，所有非终端结点中仅含有其子树中最大或最小关键字
        B+树查找，与B-树查找类似
        键树 ，是一棵度 >=2的树，树中每个结点中仅含有一个关键字组成的符号，键树又称数字查找树
        键树存储结构1，二叉链表；2，多重链表 此时键树又称Trie树，树的度较高时适合
        键树查找算法，时间效率
            关键字每位取每个字符等概率时 (1+)/2
            每个关键字位数相同是等概率时 h(1+)/2                
    11.3 哈希表
        哈希表查找(散列查找)，根据关键字K计算其对应的数据元素的存储地址
        算法复杂度 O(1) 常量时间
        核心:
        1,设计Hash函数
            Hash构造方法，对于关键字集合每个关键字key，经过哈希函数H(key)映射到哈希地址集合中的任何一个地址概率相同
            则称哈希H(key)为 Uniform 均匀哈希函数，作用：避免冲突情况即同义词的过度集中，预期哈希查找的平均效率能够达到最佳。
            1，每类同义字个数相同或大致相等  2，均匀性在于冲突较少
            构造方法:
                1,直接定址法， H(key) = a*key+b (a!=0)
                2,数字分析法
                假定预先知道可能出现的关键字子集，分析这些关键字的每一位，选择其中若干，随机位构成其哈希地址
                随机颗计算，颗结合叠加法
                选数据中随机性比较高的 其中几位作为hash地址
                k1 8 1 9 1 0 7 8 9 8 0
                k2 8 1 0 2 4 3 6 7 5 8
                k3 8 1 1 4 7 2 3 8 9 7
                如上 第4，5位随机性比较高，可以选择 H(k3) = 47
                3，平方取中法
                    取关键字平方后的中间若干位为哈希地址 的方法
                    key a1a2...a4
                        a1a2...a4 x
                     ----------------
                     a1a1a2a2..a4a4
                           ^^ 
                4，折叠法
                    将关键字分割称位数相同的若干段，各段叠加求和为哈希地址 的方法
                5，余数法
                    取关键字被不大于哈希表长m的某个树p出后的余数为哈希地址 的方法
                    H(key) = key MOD p (p<=m)  p取为质数或不含小于20质因子的合数
                    序列:[27,17,9,19,16,43,53,8,63]
                         3   1 1  3  0  3  5  0 7
                    H(key) = key MOD 8 + 链地址冲突法
                     16 17 9 27 19 43 53 8  63
                     0  1  2 3  4  5  6  7  8  9  10  11
                    所以如果要查找到 43，原余数位为3号，但是实际需要匹配27，19，43 共3次
            
        2,解决Hash冲突
        函数理论取值范围远远大于实际取值范围
            1，开放地址法  Hi(key) = (H(key)+di) MOD m  #H(key)为哈希函数 m为表长，di为增量 
            增量di的取法：1，线性探测再散列 1 ， 2 ， 3 ， …… 
                        2，二叉探测 1^2 ，－ 1^2 ， 2^2 ，－ 2^2 ， k^2， -k^2……
                        3，伪随机数探测  1，2，4，6...
               设有哈希函数 H ( key ) = key mod 7 ，哈希表的地址空间为 0 ～ 6 ，对关键字序列（ 32 ， 13 ， 49 ， 55 ， 22 ， 38 ， 21 ）按线性探测再散列和二次探测再散列的方法分别构造哈希表
               线性探测再散列：
                    32 ％ 7 = 4 ； 13 ％ 7 = 6 ； 49 ％ 7 = 0 ；
                    55 ％ 7 = 6 发生冲突，下一个存储地址（ 6 ＋ 1 ）％ 7 ＝ 0 ，仍然发生冲突，再下一个存储地址：（ 6 ＋ 2 ）％ 7 ＝ 1 未发生冲突，可以存入         
            2，再哈希法
                Hi(key) = RHi(key) (i=1,2,3...k)
                RHi(key)为不同哈希函数，不容易出现聚集，但是增加了计算时间
            3，链地址法
                将关键字同义词存储在各自单链表中
            4，公共溢出区法
                当增加关键字到哈希表遇到冲突时，将所有同义词统一存储到 公共溢出区
        3，哈希查找及分析
            查找算法
            1，给定值key对应计算的哈希地址H(key)中查找
            2，如果1查不到，根据处理冲突方法确定'下一个地址'处查找
            3，重复2直到成功，或遇到'结束标志'为止
            说明：
            '下一个地址' 和'结束标志'由处理冲突方法决定的
            查找算法中既使用算术运算，也有比较运算
            插入算法在查找失败处增加新关键字
            创建算法在循环调用插入运算实现
            删除运算的实现是在查找成功处删除某个数据元素。对于某些处理冲突的方法，删除实际上是填入'删除标志'
        问题:
            哈希表装填因子:哈希表中填入的关键字个数于哈希表长之比
            线性搜索法 
                ASL_succ = 1/2(1+1/(1-alpha))
                ASL_fail = 1/2(1+1/(1-alpha)**2)
            二次搜索法
                ASL_succ = -1/alpha ln(1-alpha)
                ASL_fail = -1/(1-alpha)
            链接地址法
                ASL_succ = 1 + alpha/2
                ASL_fail = alpha + e**(-alpha) 
            删除运算的实现是在查找成功处删除，某些时候，删除只是填入'删除标志'，并且查找算法需要调整
            特殊情况下，哈希函数 存在 无处理冲突   
            ASL成功=成功查找次数/数据元素长度 
            ASL失败=失败查找次数/数据元素长度  
## 十二 内部排序


## 十三 串
    字符串使用单独一种存储结构来存储，称为串存储结构。
    字符串的存储结构
    分类:
        空串         包含0个字符的串
        空格串       只包含空格字符的串
        子串和主串   如果a中可以找到连续字串在b中能找到，就称a是b的子串，如:a='abc'，b='abcd'
    位置
        子串在主串的位置， 串在主串中的位置，指的是子串首个字符在主串中的位置。
    存储实现
        顺序存储    静态数组，在c中如，char a[13] = "www.google.cn"
        堆分配存储  用动态数组存储字符串
            malloc 函数 手工申请，使用完成后free释放
        块链存储    用链表存储字符串 
    算法(串模式匹配算法)
        1，BF算法，普通模式匹配算法，暴力匹配算法
        一种用来判断两个串之间 是否具有 '子串-主串'关系的算法
        基本思想：将用户指定的两个串A 和串B，使用串的定长顺序存储结构存储起来，然后使用循环实现两个串的模式匹配过程
        复杂度:
        最理想的时间复杂度 O(n)，n 表示串 A 的长度，即第一次匹配就成功
        最坏情况的时间复杂度为 O(n*m),两个串每次匹配，都必须匹配至串 A 的最末尾才能判断匹配失败，因此运行了 n*m 次
        特点:
            没有任何技巧，效率较低
            
        2，KMP算法
         Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，
         这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法
         2.1,基于最大长度表匹配
         2.2,基于next数组匹配
         时间复杂度
         如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)
        3，BM算法
         字符串匹配算法：Boyer-Moore算法，简称BM算法
         该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高
         规则:
         3.1 坏字符规则
         当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，
         移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1   
         3.2 好后缀规则
         当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1
         时间复杂度，O(n) n为模式串长度
       4，Sunday算法  
         Sunday算法由Daniel M.Sunday在1990年提出
         规则:
            1，Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。
            2，如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1
            3，否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1
         例:
         现有文本串 "subneting setwork algorithm" 找到模式串"setwork"
         step_1，将文本串和模式串头对齐
         subneting setwork algorithm
         setwork
         ^
         step_2, 发现模式串第二个字符不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一字符，即subneting的 n
         因为模式串中没有n，所以模式串跳过这些，向右移动位数 = 模式串长度+1 = 7+1=8，从n之后的g开始匹配
         subneting setwork algorithm
                 setwork
                  ^
         step_3，第一个字符就不匹配,看参加匹配的文本串的下一位字符是r，他出现在模式串的-2位，于是把模式串向右移动2位
         使两个r对齐
         subneting setwork algorithm
                   setwork
                         ^
         step_4，匹配成功，这里只移动了两次就匹配成功，效率较高。
         
         
         